{
  "transpiled": true,
  "noir_version": "1.0.0-beta.3+0000000000000000000000000000000000000000",
  "name": "Bundler",
  "functions": [
    {
      "name": "constructor",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "initializer"
      ],
      "abi": {
        "parameters": [
          {
            "name": "admin",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17468734814123129055": {
            "error_kind": "string",
            "string": "invalid admin address"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "constructor"
      ]
    },
    {
      "name": "send_tokens_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "to",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "reward_token",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "stable_token",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "stable_amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "reward_amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "send_tokens_public"
      ]
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "939615093317106671": {
            "error_kind": "string",
            "string": "Invalid response from registry"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2236649814169388962": {
            "error_kind": "string",
            "string": "PublicImmutable already initialized"
          },
          "2830029349304997821": {
            "error_kind": "fmtstring",
            "length": 27,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "4939791462094160055": {
            "error_kind": "string",
            "string": "Message not authorized by account"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "10132274202417587856": {
            "error_kind": "string",
            "string": "invalid nonce"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17468734814123129055": {
            "error_kind": "string",
            "string": "invalid admin address"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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AoAOLgKAC4AOAQCADgACgA4uAoAJgA4jAAAmyCMAACchKACADwQAAgUAgAuAD4AOKACAEAQAAwEAgA6AEIAPLgAAAYAFAQAAAYAPAAEoAYAFBAABAQCABQACgA8uAoALgA8BAIAPAAKADy4CgA6ADyMAACchKACADQQAAwEAgAWADYAMCwCAA4AFgA0kAIANAAAnhQEAgAqACIAPLgCACoAQLgCADIARCwCAEIAPgBIkAIASAAAnhS4BgBCADi4CgA6AEQEAgBAAAoAQAQCAEQACgBEjAAAnVAEAgAyACIAGJi4BgAOABwEAgAMAAoALLgGAC4AIAQCACwACgAsuAYALgAkBAIALAAKACgEAgAiABIALDwCAC4AJgAwLAIAHAAKADSQAgAwAACfdIwAAKE0kAIANAAAn6iMAACgDLgCAA4AFAQCABQACgA4uAoALgA4jAAAoSCgAgA8EAAMBAIAJgA+ADi4AAAGABQEAAAGADgABKAGABQQAAQEAgAUAAoAOLgKAC4AOAQCADgACgA4uAoAJgA4jAAAoSCMAACihKACADwQAAgUAgAuAD4AOKACAEAQAAwEAgA6AEIAPLgAAAYAFAQAAAYAPAAEoAYAFBAABAQCABQACgA8uAoALgA8BAIAPAAKADy4CgA6ADyMAACihKACADQQAAwEAgAWADYAMAQCADIAEgA0DAIAIAAKADgEAgA2ADoAPAQCACoAOgBANAIAQgAqADiQAgA4AACkBLgGAEIARLgKAEYAPAwCAEAACgBADAIAPAAKADyMAACjQLgCADIAGJioBAAEFxWvEWg4QAAI8AQECJg==",
      "debug_symbols": "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",
      "brillig_names": [
        "public_dispatch"
      ]
    },
    {
      "name": "cancel_stable_authwit",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "inner_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "notify_created_nullifier_oracle_wrapper"
      ],
      "verification_key": "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"
    },
    {
      "name": "cancel_reward_authwit",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "inner_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "notify_created_nullifier_oracle_wrapper"
      ],
      "verification_key": "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"
    },
    {
      "name": "process_log",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "parameters": [
          {
            "name": "log_ciphertext",
            "type": {
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec",
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 18,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "tx_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "unique_note_hashes_in_tx",
            "type": {
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec",
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 64,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "first_nullifier_in_tx",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2588366281349374274": {
            "error_kind": "fmtstring",
            "length": 136,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "3473764466780631008": {
            "error_kind": "fmtstring",
            "length": 106,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5533887251808526417": {
            "error_kind": "fmtstring",
            "length": 120,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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e9fStfeupWvvXUvX3ruWrr13LV1771q69t61dO29a+nae9fStfeupWvvXUvX3ruWrr13LV1771q69t61dO29a+nae9fStfeupWvvXUvX3ruWrr13LV1771q69t61dO29a+nae9fStfeupWvvXUvX3ruWrr13LV1771q69t61dO29a+nae9fStfeupWvvXUvX3ruWrr13LV1771q69t61dO29a+nae9fStfeupWvvXUvX3ruWrr13LV1771q69t61dO29a+nae9fStfeupWvvXUvX3ruWrr13LV1771q69t61dO29a+nae9fStfeupWvvXUvX3ruWrr13LV1771q69t61dO29a+nae9fStfeupWvvXUvX3ruWrr13LV1771q69t61dO29a+nae9fStfeupWvvXUvX3ruWrr13LV1771q69t61dO29a+nae9fStfeupWvvXUvX3ruWrr13LV1771q69t619O29a+nbe9fSt/eupW/vXUs/Nbd6+/betfTtvWvp23vX0rf3rqVv711L3967lr69dy19e+9a+vbetfTtvWvp23vX0rf3rqVv711L3967lv6Ody3DevFjV0kfX2x0issvG/Uch5+Hf8d7mSWHr2QPXzc+fOPTOvwYXob/fq1Vq6lWq/BmqhnH1BsiXgjLbz+2vaa3VeqO91NzQ/LtDSncMST1HFJ4H1Jsb0g3RLxo7Dqk8O64O95PzQ1JtTck3d6QbogKMa2CLuUu/tUifRmIU+Y5jl9jerv6UV34vPixur1cuxhrRzLWjWSsH8nYMJKxcSRj00DG3vFW9H3GqpGM1SMZO5KCuuPt8/uMHUlB2ZEUlB1JQdmRFJQdSUG5vuKsXS72Tm0Y29dq7JdRex83jG19NXbKrcYa+8XY2YDWV9isAa2vmlkDWl8Jcwb45vNDq54GuMyEV0nHdX1IOr1tWvnmM8Sy5jYfu8qa23yWWNZcO5a5P61N5qf4Kk8JVZ5SKLyGaX1K9O9PSTWeUqhJgXuef/AqZPgblsRAT0+pqTevjdPC3WhS5toUlzmU0tdrZ0vVMJbqYSw1w1hqh7HUDWOpH8bSMIylcRhL0yiWxmE0UhxGIxVqXOL1ekI7KH9sqX7WTXXQL2mF3jLVpAXDaL9ePI/ftD3+ZKYl70hGueOLMwfdC7VPacTWckfFC/Vw6Q8X3zouzq64+PS75kah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/irh8VcJj79KePwt9Cb7feMXHn+V8PirhMdfJTz+KuHxVwuPv1p4/NXC468WHn8LdZO4b/zC468WHn+18PirhcdfLTz+GuHx1wiPv0Z4/DXC42+hji73jV94/DXC468RHn+N8PhrhMdfKzz+WuHx1wqPv1Z4/C3UVem+8QuPv1Z4/LXC468VHn+t8PjrhMdfJzz+OuHx1wmPv4W6it03fuHx1wmPv054/HXC468THn+98Pjrhcdf4f2vnPD+V054/ysnvP+VE97/ygnvf+WE979ywvtfOeH9r5zw/ldOeP8rJ7z/lRPe/8oJ73/lhPe/csL7Xznh/a+c8P5XTnj/Kye8/5UT3v/KCe9/5YT3v3LC+1854f2vnPD+V054/ysnvP+VE97/ygnvf+WE979ywvtfOeH9r5zw/ldOeP8rJ7z/lRPe/8oJ73/lhfe/8sL7X3nh/a+88P5XfpIdf73w/ldeeP8rL7z/lRfe/8oL73/lhfe/8sL7X3nh/a+88P5XXnj/Ky+8/5UX3v/KC+9/5YX3v/LC+1954f2vvPD+V154/ysvvP+VF97/ygvvf+WF97/ywvtfeeH9r7zw/ldeeP8rL7z/lRfe/8oL73/lhfe/8sL7X3nh/a+88P5XXnj/Ky+8/5UX3v/KC+9/5YX3v/LC+1954f2vvPD+V154/ysvvP+VF97/ygvvf+WF97/ywvtfeeH9r7zw/ldeeP8rL7z/lRfe/8oL73/lhfe/8sL7X3nh/a+88P5XXnj/Ky+8/5UX3v/KC+9/5YX3v/LC+1954f2vvPD+V154/ysvvP+VF97/ygvvf+WF97/ywvtfeeH9r7zw/ldeeP8rL7z/lRfe/8oL73/lhfe/8sL7X3nh/a+88P5XXnj/Ky+8/5UX3v/KC+9/5YX3v/LC+1954f2vvPD+V154/ysvvP+VF97/ygvvf+WF97/ywvtfBeH9r4Lw/ldBeP+rILz/VZhkx98gvP9VEN7/KgjvfxWE978KwvtfBeH9r4Lw/ldBeP+rILz/VRDe/yoI738VhPe/CsL7XwXh/a+C8P5XQXj/qyC8/1UQ3v8qCO9/FYT3vwrC+18F4f2vgvD+V6H1/lfWGPt5sTU2ZYzVaR2GUc9B+09bG4/VJW1tva+WNcEvttqcrcqGBRjllHkOOm1d7adlGP5lyCqZT2QaVww3ItO4FrkRmcZV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",
      "brillig_names": [
        "process_log"
      ]
    },
    {
      "name": "send_tokens_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "reward_token",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "stable_token",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "stable_amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "reward_amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "directive_integer_quotient",
        "directive_invert"
      ],
      "verification_key": "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"
    },
    {
      "name": "exchange_tokens_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "from",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "stable_token",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "reward_token",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "stable_amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "reward_amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "939615093317106671": {
            "error_kind": "string",
            "string": "Invalid response from registry"
          },
          "4939791462094160055": {
            "error_kind": "string",
            "string": "Message not authorized by account"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "10132274202417587856": {
            "error_kind": "string",
            "string": "invalid nonce"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "exchange_tokens_public"
      ]
    },
    {
      "name": "sync_notes",
      "is_unconstrained": true,
      "custom_attributes": [],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "sync_notes"
      ]
    },
    {
      "name": "exchange_tokens_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "from",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "stable",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "reward",
            "type": {
              "kind": "struct",
              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "stable_amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "reward_amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "authwit::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "args_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "authwit::aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "authwit::aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "authwit::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "authwit::aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "authwit::aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "authwit::aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "4939791462094160055": {
            "error_kind": "string",
            "string": "Message not authorized by account"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "10132274202417587856": {
            "error_kind": "string",
            "string": "invalid nonce"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "12822839658937144934": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18194595712952743247": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "discover_new_messages",
        "store_in_execution_cache_oracle_wrapper",
        "call_private_function_internal",
        "load",
        "notify_created_nullifier_oracle_wrapper",
        "store_in_execution_cache_oracle_wrapper",
        "directive_invert",
        "directive_integer_quotient"
      ],
      "verification_key": "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"
    }
  ],
  "outputs": {
    "globals": {
      "notes": [
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000001"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "ValueNote"
            },
            {
              "fields": [
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000001"
            },
            {
              "kind": "string",
              "value": "UintNote"
            },
            {
              "fields": [
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        },
        {
          "fields": [
            {
              "kind": "integer",
              "sign": false,
              "value": "0000000000000000000000000000000000000000000000000000000000000000"
            },
            {
              "kind": "string",
              "value": "ValueNote"
            },
            {
              "fields": [
                {
                  "name": "value",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000000"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "owner",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000001"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                },
                {
                  "name": "randomness",
                  "value": {
                    "fields": [
                      {
                        "name": "index",
                        "value": {
                          "kind": "integer",
                          "sign": false,
                          "value": "0000000000000000000000000000000000000000000000000000000000000002"
                        }
                      },
                      {
                        "name": "nullable",
                        "value": {
                          "kind": "boolean",
                          "value": false
                        }
                      }
                    ],
                    "kind": "struct"
                  }
                }
              ],
              "kind": "struct"
            }
          ],
          "kind": "tuple"
        }
      ],
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Bundler"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "from",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "stable",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "reward",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "stable_amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "reward_amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Bundler::exchange_tokens_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Bundler::exchange_tokens_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "inner_hash",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Bundler::cancel_stable_authwit_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Bundler::cancel_stable_authwit_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "reward_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "stable_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "stable_amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "reward_amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "Bundler::send_tokens_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Bundler::send_tokens_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "inner_hash",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Bundler::cancel_reward_authwit_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Bundler::cancel_reward_authwit_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "admin",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Bundler::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Bundler::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "reward_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "stable_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "stable_amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "reward_amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "Bundler::send_tokens_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Bundler::send_tokens_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "from",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "stable_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "reward_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "authwit::aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "stable_amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "reward_amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Bundler::exchange_tokens_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Bundler::exchange_tokens_public_abi"
        }
      ]
    }
  },
  "file_map": {
    "115": {
      "path": "/c/Users/emili/nargo/github.com/AztecProtocol/aztec-packages/v0.82.0/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\nmod test;\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n"
    },
    "119": {
      "path": "/c/Users/emili/nargo/github.com/AztecProtocol/aztec-packages/v0.82.0/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::{\n    discovery::private_notes::MAX_NOTE_PACKED_LEN,\n    macros::{\n        dispatch::generate_public_dispatch,\n        functions::{\n            stub_registry,\n            utils::{create_message_discovery_call, find_and_transform_top_level_unconstrained_fns},\n        },\n        notes::{generate_note_export, NOTES},\n        storage::STORAGE_LAYOUT_NAME,\n        utils::{get_trait_impl_method, module_has_storage},\n    },\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `process_log` and `sync_notes` functions PXE requires in order to discover notes.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    find_and_transform_top_level_unconstrained_fns(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let process_log = generate_process_log();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_notes = generate_sync_notes();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $process_log\n        $public_dispatch\n        $sync_notes\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                nonce: Field,\n            ) -> Option<aztec::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_process_log() -> Quoted {\n    // This mandatory function processes a log emitted by the contract. This is currently used to process private logs\n    // and perform message discovery, resulting in new private notes, partial notes and events.\n    // The bulk of the work of this function is done by aztec::discovery::do_process_log, so all we need to do is call\n    // that function.\n\n    // We'll produce the entire body of the function in one go and then insert it into the function.\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        quote {\n            unconstrained fn process_log(\n                log_ciphertext: BoundedVec<Field, dep::aztec::protocol_types::constants::PRIVATE_LOG_SIZE_IN_FIELDS>,\n                tx_hash: Field,\n                unique_note_hashes_in_tx: BoundedVec<Field, dep::aztec::protocol_types::constants::MAX_NOTE_HASHES_PER_TX>,\n                first_nullifier_in_tx: Field,\n                recipient: aztec::protocol_types::address::AztecAddress,\n            ) {\n                // Because this unconstrained function is injected after the contract is processed by the macros, it'll\n                // not be modified by the macros that alter unconstrained functions. As such, we need to manually inject\n                // the unconstrained execution context since it will not be available otherwise.\n                let context = dep::aztec::context::unconstrained_context::UnconstrainedContext::new();\n\n                // TODO(#10727): allow other contracts to process logs and deliver notes\n                let contract_address = context.this_address();\n\n                aztec::discovery::private_logs::do_process_log(\n                    contract_address,\n                    log_ciphertext,\n                    tx_hash,\n                    unique_note_hashes_in_tx,\n                    first_nullifier_in_tx,\n                    recipient,\n                    _compute_note_hash_and_nullifier,\n                );\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            unconstrained fn process_log(\n                _log_ciphertext: BoundedVec<Field, dep::aztec::protocol_types::constants::PRIVATE_LOG_SIZE_IN_FIELDS>,\n                _tx_hash: Field,\n                _unique_note_hashes_in_tx: BoundedVec<Field, dep::aztec::protocol_types::constants::MAX_NOTE_HASHES_PER_TX>,\n                _first_nullifier_in_tx: Field,\n                _recipient: aztec::protocol_types::address::AztecAddress,\n            ) {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_notes() -> Quoted {\n    let message_discovery_call = create_message_discovery_call();\n    quote {\n        unconstrained fn sync_notes() {\n            // Because this unconstrained function is injected after the contract is processed by the macros, it'll not\n            // be modified by the macros that alter unconstrained functions. As such, we need to manually inject the\n            // unconstrained execution context since it will not be available otherwise.\n            let context = dep::aztec::context::unconstrained_context::UnconstrainedContext::new();\n\n            $message_discovery_call\n        }\n    }\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n"
    },
    "120": {
      "path": "/c/Users/emili/nargo/github.com/AztecProtocol/aztec-packages/v0.82.0/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let name = function.name();\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "123": {
      "path": "/c/Users/emili/nargo/github.com/AztecProtocol/aztec-packages/v0.82.0/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr",
      "source": "use crate::macros::utils::{\n    add_to_field_slice, AsStrQuote, compute_fn_selector, is_fn_private, is_fn_view,\n};\nuse std::meta::{type_of, unquote};\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\ncomptime global SERIALIZED_ARGS_SLICE_NAME: Quoted = quote { serialized_args };\n\npub comptime fn stub_fn(f: FunctionDefinition) -> Quoted {\n    let is_static_call = is_fn_view(f);\n    let is_void = f.return_type() == type_of(());\n\n    if is_fn_private(f) {\n        if is_static_call {\n            if is_void {\n                create_private_static_void_stub(f)\n            } else {\n                create_private_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_private_void_stub(f)\n            } else {\n                create_private_stub(f)\n            }\n        }\n    } else {\n        if is_static_call {\n            if is_void {\n                create_public_static_void_stub(f)\n            } else {\n                create_public_static_stub(f)\n            }\n        } else {\n            if is_void {\n                create_public_void_stub(f)\n            } else {\n                create_public_stub(f)\n            }\n        }\n    }\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n\n    // Example of what the fold(...) below will generate for `target_address` and `fee_juice_limit_per_tx` function\n    // parameters:\n    // ```\n    // let mut serialized_args =  &[];\n    // serialized_args = serialized_args.append(aztec::protocol_types::traits::Serialize::serialize(target_address));\n    // serialized_args = serialized_args.push_back(fee_juice_limit_per_tx as Field);\n    // ```\n    let serialized_args_slice_construction = fn_parameters.fold(\n        quote {\n            let mut $SERIALIZED_ARGS_SLICE_NAME = &[];\n        },\n        |args, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let arg_to_append = add_to_field_slice(SERIALIZED_ARGS_SLICE_NAME, name, typ);\n            quote {\n                $args\n                $arg_to_append\n            }\n        },\n    );\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len,\n        fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_private_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_SLICE_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_void_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface<$fn_name_len> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticVoidCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                serialized_args\n            )\n        }\n    }\n}\n"
    },
    "124": {
      "path": "/c/Users/emili/nargo/github.com/AztecProtocol/aztec-packages/v0.82.0/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "127": {
      "path": "/c/Users/emili/nargo/github.com/AztecProtocol/aztec-packages/v0.82.0/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_initializer, is_fn_internal,\n        is_fn_private, is_fn_public, is_fn_view, modify_fn_body, module_has_initializer,\n        module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, &[], false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn find_and_transform_top_level_unconstrained_fns(m: Module) {\n    // Top-level unconstrained fns are contract entrypoints, but they're not explicitly designated in any way. They're\n    // the fallback case for a function that matches no other rules.\n    // TODO(#12743): improve this\n\n    // We first find non-standard contract entrypoints, i.e. functions in the `contract` mod that are not private or\n    // public, but which *are* contract entrypoints (i.e. they're not opting out via the #[test] or\n    // #[contract_library_method] attributes). Ideally entrypoints would be explicitly designated instead.\n    let non_private_public_entrypoint_functions = m.functions().filter(|f: FunctionDefinition| {\n        !is_fn_private(f)\n            & !is_fn_public(f)\n            & !f.has_named_attribute(\"contract_library_method\")\n            & !f.has_named_attribute(\"test\")\n    });\n\n    // TODO: uncomment the code below and emit a warning once support for them is added to Noir (tracked in\n    // https://github.com/noir-lang/noir/issues/7714). We can't simply print a message since that'd otherwise break the\n    // output of utils such as `nargo test --list-tests`.\n    // // We don't expect to see any custom constrained entrypoints (i.e. private functions created outside of aztec-nr's\n    // // #[private] macro, possibly resulting in a non-standard interface).\n    // for f in non_private_public_entrypoint_functions.filter(|f: FunctionDefinition| {\n    //     !f.is_unconstrained()\n    // }) {\n    //     let name = f.name();\n    //     warn(\n    //         f\"found private contract function '{name}' which does not have the #[private] attribute - make sure you know what you're doing!\",\n    //     );\n    // }\n\n    // An unconstrained contract entrypoints is what we call a top-level unconstrained function, to which we apply the\n    // appropriate transformation. Ideally these would be explicitly designated as such instead.\n    for f in non_private_public_entrypoint_functions.filter(|f: FunctionDefinition| {\n        f.is_unconstrained()\n    }) {\n        transform_top_level_unconstrained(f);\n    }\n}\n\npub(crate) comptime fn transform_top_level_unconstrained(f: FunctionDefinition) {\n    let context_creation = quote { let mut context = dep::aztec::context::unconstrained_context::UnconstrainedContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All unconstrained functions perform message discovery, since they may need to access private notes that would be\n    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually\n    // attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_return_public(true);\n    f.set_body(modified_body);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n"
    },
    "129": {
      "path": "/c/Users/emili/nargo/github.com/AztecProtocol/aztec-packages/v0.82.0/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::{macros::utils::AsStrQuote, note::note_getter_options::PropertySelector};\nuse protocol_types::meta::{derive_packable_and_get_packed_len, generate_serialize_to_fields};\nuse std::{\n    collections::umap::UHashMap,\n    hash::{BuildHasherDefault, Hash, Hasher, poseidon2::Poseidon2Hasher},\n    meta::{type_of, unquote},\n};\n\n/// A map from note type to (note_struct_definition, note_packed_len, note_type_id, fields).\n/// `fields` is an array of tuples where each tuple contains the name of the field/struct member (e.g. `amount`\n/// in `TokenNote`), the index of where the packed member starts in the packed note and a flag indicating\n/// whether the field is nullable or not.\npub comptime mut global NOTES: UHashMap<Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]), BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\npub comptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < 128 as u32,\n        \"A contract can contain at most 128 different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates a quote that implements `Packable` for a given struct `s`.\n/// If the note struct already implements `Packable`, we return an empty quote.\ncomptime fn derive_packable_if_not_implemented_and_get_len(s: TypeDefinition) -> (Quoted, u32) {\n    // We try to get the packed length of the note struct. If it does not implement `Packable`, we get Option::none()\n    let packed_len_typ = std::meta::typ::fresh_type_variable();\n    // We don't care about the result of the implements check. We just want the get the packed length.\n    let _ = s.as_type().implements(\n        quote { crate::protocol_types::traits::Packable<$packed_len_typ> }.as_trait_constraint(),\n    );\n    let maybe_packed_length = packed_len_typ.as_constant();\n\n    if maybe_packed_length.is_some() {\n        // We got some packed length meaning that the note struct implements `Packable`. For this reason we return\n        // an empty quote for the implementation and the packed length.\n        (quote {}, maybe_packed_length.unwrap())\n    } else {\n        // We didn't manage to get the packed length which means the note struct doesn't implement `Packable`\n        // so we derive it and return it along with the packed length.\n        derive_packable_and_get_packed_len(s)\n    }\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_interface(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::utils::arrays::array_concat(aztec::protocol_types::traits::Packable::pack(self), [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::prelude::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _): (Quoted, Type)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates note export for a given note struct `s`. The export is a global variable that contains note type id,\n/// note name and information about note fields (field name, index and whether the field is nullable or not).\n///\n/// Example:\n/// ```\n/// struct TokenNoteFields_5695262104 {\n///     amount: aztec::note::note_field::NoteField,\n///     owner: aztec::note::note_field::NoteField\n/// }\n///\n/// #[abi(notes)]\n/// global TokenNote_EXPORTS_5695262104: (Field, str<8>, TokenNoteFields_5695262104) = (\n///     0,\n///     \"TokenNote\",\n///     TokenNoteFields_5695262104 {\n///         amount: aztec::note::note_field::NoteField { index: 0, nullable: false },\n///         owner: aztec::note::note_field::NoteField { index: 1, nullable: false }\n///     }\n/// );\n///\n/// Randomly looking value at the end of the export name is generated by hashing the note struct type and is included\n/// to prevent naming collisions in case there are multiple notes with the same name imported in a contract.\npub(crate) comptime fn generate_note_export(\n    s: TypeDefinition,\n    note_type_id: Field,\n    fields: [(Quoted, u32, bool)],\n) -> Quoted {\n    let name = s.name();\n    let mut hasher = Poseidon2Hasher::default();\n    s.as_type().hash(&mut hasher);\n    let hash = hasher.finish() as u32;\n    let global_export_name = f\"{name}_EXPORTS_{hash}\".quoted_contents();\n    let note_fields_name = f\"{name}Fields_{hash}\".quoted_contents();\n    let (note_name_as_str, _) = name.as_str_quote();\n    let note_name_str_len = unquote!(quote { $note_name_as_str.as_bytes().len() });\n\n    let mut note_fields = &[];\n    let mut note_field_constructors = &[];\n    for field in fields {\n        let (name, index, nullable) = field;\n        note_fields = note_fields.push_back(quote { $name: aztec::note::note_field::NoteField });\n        note_field_constructors = note_field_constructors.push_back(\n            quote { $name: aztec::note::note_field::NoteField { index: $index, nullable: $nullable }},\n        );\n    }\n\n    let note_fields = note_fields.join(quote {,});\n    let note_field_constructors = note_field_constructors.join(quote {,});\n\n    quote {\n        pub struct $note_fields_name {\n            pub $note_fields\n        }\n\n        #[abi(notes)]\n        global $global_export_name: (Field, str<$note_name_str_len>, $note_fields_name) = ($note_type_id, $note_name_as_str, $note_fields_name { $note_field_constructors });\n    }\n}\n\n/// Registers a note struct `note` with the given `note_packed_len`, `note_type_id`, `fixed_fields` and\n/// `nullable_fields` in the global `NOTES` map.\ncomptime fn register_note(\n    note: TypeDefinition,\n    note_packed_len: u32,\n    note_type_id: Field,\n    fixed_fields: [(Quoted, Type, u32)],\n    nullable_fields: [(Quoted, Type, u32)],\n) {\n    let mut fields = &[];\n    for field in fixed_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, false));\n    }\n    for field in nullable_fields {\n        let (name, _, index) = field;\n        fields = fields.push_back((name, index, true));\n    }\n\n    NOTES.insert(note.as_type(), (note, note_packed_len, note_type_id, fields));\n}\n\n/// Separates note struct members into fixed and nullable ones. It also stores the index of where each struct member\n/// starts in the serialized note. Note that each struct member can occupy multiple fields (as in Field type).\ncomptime fn index_note_fields(\n    s: TypeDefinition,\n    nullable_fields: [Quoted],\n) -> ([(Quoted, Type, u32)], [(Quoted, Type, u32)]) {\n    let mut indexed_fixed_fields: [(Quoted, Type, u32)] = &[];\n    let mut indexed_nullable_fields = &[];\n    let mut counter: u32 = 0;\n    for field in s.fields_as_written() {\n        let (name, typ) = field;\n        if nullable_fields.all(|field| field != name) {\n            indexed_fixed_fields = indexed_fixed_fields.push_back((name, typ, counter));\n        } else {\n            indexed_nullable_fields = indexed_nullable_fields.push_back((name, typ, counter));\n        }\n        let (serialization_fields, _) = generate_serialize_to_fields(name, typ, &[], true);\n        // Each struct member can occupy multiple fields so we need to increment the counter accordingly\n        counter += serialization_fields.len();\n    }\n    (indexed_fixed_fields, indexed_nullable_fields)\n}\n\n/// Generates the following:\n/// - NoteTypeProperties\n/// - NoteType trait implementation\n/// - NoteHash trait implementation\n/// - Packable implementation\n///\n/// Registers the note in the global `NOTES` map.\n///\n/// For more details on the generated code, see the individual functions.\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $note_hash_impl\n        $packable_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - Packable implementation: Enables serialization/deserialization of the note\n///\n/// # Registration\n/// Registers the note in the global `NOTES` map with:\n/// - Note type ID\n/// - Packed length\n/// - Field indices and nullability\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    let (packable_impl, note_packed_len) = derive_packable_if_not_implemented_and_get_len(s);\n    let note_type_id = get_next_note_type_id();\n\n    let (indexed_fixed_fields, indexed_nullable_fields) = index_note_fields(s, &[]);\n    register_note(\n        s,\n        note_packed_len,\n        note_type_id,\n        indexed_fixed_fields,\n        indexed_nullable_fields,\n    );\n\n    let note_properties = generate_note_properties(s);\n    let note_interface_impl = generate_note_interface(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_interface_impl\n        $packable_impl\n    }\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    assert(\n        has_owner,\n        \"Note must have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "131": {
      "path": "/c/Users/emili/nargo/github.com/AztecProtocol/aztec-packages/v0.82.0/noir-projects/aztec-nr/aztec/src/macros/utils.nr",
      "source": "use std::meta::unquote;\n\npub(crate) comptime fn get_fn_visibility(f: FunctionDefinition) -> Quoted {\n    if f.has_named_attribute(\"private\") {\n        quote { private }\n    } else if f.has_named_attribute(\"public\") {\n        quote { public }\n    } else {\n        panic(f\"Function is neither private nor public\")\n    }\n}\n\npub(crate) comptime fn is_fn_private(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"private\")\n}\n\npub(crate) comptime fn is_fn_public(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"public\")\n}\n\npub(crate) comptime fn is_fn_view(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"view\")\n}\n\npub(crate) comptime fn is_fn_internal(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"internal\")\n}\n\npub(crate) comptime fn is_fn_initializer(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"initializer\")\n}\n\npub(crate) comptime fn fn_has_noinitcheck(f: FunctionDefinition) -> bool {\n    f.has_named_attribute(\"noinitcheck\")\n}\n\n/// Takes a function body as a collection of expressions, and alters it by prepending and appending quoted values.\npub(crate) comptime fn modify_fn_body(body: [Expr], prepend: Quoted, append: Quoted) -> Expr {\n    // We need to quote the body before we can alter its contents, so we fold it by quoting each expression.\n    let mut body_quote = body.fold(quote {}, |full_quote: Quoted, expr: Expr| {\n        let expr_quote = expr.quoted();\n        quote {\n                $full_quote\n                $expr_quote\n            }\n    });\n    body_quote = quote {\n        {\n            $prepend\n            $body_quote\n            $append\n        }\n    };\n    let body_expr = body_quote.as_expr();\n    body_expr.expect(f\"Body is not an expression: {body_quote}\")\n}\n\npub(crate) comptime fn add_to_field_slice(slice_name: Quoted, name: Quoted, typ: Type) -> Quoted {\n    if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        quote { $slice_name = $slice_name.push_back($name as Field); }\n    } else if typ.as_data_type().is_some() {\n        // We invoke serialize as a static trait function rather than calling $name.serialize() directly in the quote\n        // to avoid \"trait not in scope\" compiler warnings.\n        quote { $slice_name = $slice_name.append(aztec::protocol_types::traits::Serialize::serialize($name)); }\n    } else if typ.as_array().is_some() {\n        let (element_type, _) = typ.as_array().unwrap();\n        let serialized_name = f\"{name}_serialized\".quoted_contents();\n        // We invoke serialize as a static trait function rather than calling x.serialize() directly in the quote\n        // to avoid \"trait not in scope\" compiler warnings.\n        quote {\n            let $serialized_name = $name.map(|x: $element_type | aztec::protocol_types::traits::Serialize::serialize(x));\n            for i in 0..$name.len() {\n                $slice_name = $slice_name.append($serialized_name[i].as_slice());\n            }\n        }\n    } else if typ.as_str().is_some() {\n        quote {\n            $slice_name = $slice_name.append($name.as_bytes().map(| byte: u8 | byte as Field).as_slice());\n        }\n    } else {\n        panic(\n            f\"Cannot add to slice: unsupported type {typ} variable {name}\",\n        )\n    }\n}\n\n/// Adds a value to a hash::ArgsHasher. Structs and values inside arrays are required to implement the Serialize trait.\npub(crate) comptime fn add_to_hasher(hasher_name: Quoted, name: Quoted, typ: Type) -> Quoted {\n    if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        quote { $hasher_name.add($name as Field); }\n    } else if typ.as_data_type().is_some() {\n        quote { $hasher_name.add_multiple(dep::aztec::protocol_types::traits::Serialize::serialize($name)); }\n    } else if typ.as_array().is_some() {\n        let (element_type, _) = typ.as_array().unwrap();\n        let serialized_name = f\"{name}_serialized\".quoted_contents();\n        quote {\n           let $serialized_name = $name.map(|x: $element_type | dep::aztec::protocol_types::traits::Serialize::serialize(x));\n            for i in 0..$name.len() {\n                $hasher_name.add_multiple($serialized_name[i]);\n            }\n        }\n    } else if typ.as_str().is_some() {\n        quote {\n            $hasher_name.add_multiple($name.as_bytes().map(| byte: u8 | byte as Field));\n        }\n    } else {\n        panic(\n            f\"Cannot add to hasher: unsupported type {typ} of variable {name}\",\n        )\n    }\n}\n\ncomptime fn signature_of_type(typ: Type) -> Quoted {\n    if typ.is_field() {\n        quote {Field}\n    } else if typ.as_integer().is_some() {\n        let (is_signed, bit_size) = typ.as_integer().unwrap();\n        if is_signed {\n            f\"i{bit_size}\".quoted_contents()\n        } else {\n            f\"u{bit_size}\".quoted_contents()\n        }\n    } else if typ.is_bool() {\n        quote {bool}\n    } else if typ.as_str().is_some() {\n        let str_len_typ = typ.as_str().unwrap();\n        let str_len = str_len_typ.as_constant().unwrap();\n        f\"str<{str_len}>\".quoted_contents()\n    } else if typ.as_array().is_some() {\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let element_typ_quote = signature_of_type(element_type);\n        f\"[{element_typ_quote};{array_len}]\".quoted_contents()\n    } else if typ.as_data_type().is_some() {\n        let (s, generics) = typ.as_data_type().unwrap();\n        let field_signatures = s\n            .fields(generics)\n            .map(|(_, typ): (Quoted, Type)| signature_of_type(typ))\n            .join(quote {,});\n        f\"({field_signatures})\".quoted_contents()\n    } else if typ.as_tuple().is_some() {\n        // Note that tuples are handled the same way as structs\n        let types = typ.as_tuple().unwrap();\n        let field_signatures = types.map(|typ: Type| signature_of_type(typ)).join(quote {,});\n        f\"({field_signatures})\".quoted_contents()\n    } else {\n        panic(f\"Unsupported type {typ}\")\n    }\n}\n\npub(crate) trait AsStrQuote {\n    fn as_str_quote(self) -> (Self, u32);\n}\n\nimpl<let N: u32, Env> AsStrQuote for Quoted {\n    // Used to convert an arbitrary quoted type into a quoted string, removing whitespace between tokens\n    comptime fn as_str_quote(self) -> (Quoted, u32) {\n        let tokens = self.tokens();\n        let mut acc: [u8] = &[];\n        let mut total_len: u32 = 0;\n        for token in tokens {\n            let token_as_fmt_str = f\"{token}\";\n            let token_as_str = unquote!(quote {$token_as_fmt_str});\n            let token_len = unquote!(quote { $token_as_str.as_bytes().len() });\n            let token_as_bytes = unquote!(quote { $token_as_str.as_bytes().as_slice() });\n            total_len += token_len;\n            acc = acc.append(token_as_bytes);\n        }\n        let result = unquote!(\n            quote {\n                let signature_as_array: [u8; $total_len] = $acc.as_array();\n                signature_as_array.as_str_unchecked()\n            },\n        );\n        (quote { $result }, total_len)\n    }\n}\n\npub(crate) comptime fn compute_fn_selector(f: FunctionDefinition) -> Field {\n    // The function selector is computed from the function signature, which is made up of the function name and types of\n    // parameters, but not including the return type. For example, given:\n    //\n    // fn foo(a: Field, b: AztecAddress) -> Field\n    //\n    // The signature will be \"foo(Field,AztecAddress)\".\n    let fn_name = f.name();\n    let args_signatures =\n        f.parameters().map(|(_, typ): (Quoted, Type)| signature_of_type(typ)).join(quote {,});\n    let signature_quote = quote { $fn_name($args_signatures) };\n    let (signature_str_quote, _) = signature_quote.as_str_quote();\n\n    let computation_quote = quote {\n        protocol_types::traits::ToField::to_field(protocol_types::abis::function_selector::FunctionSelector::from_signature($signature_str_quote))\n    };\n    unquote!(computation_quote)\n}\n\npub(crate) comptime fn compute_event_selector(s: TypeDefinition) -> Field {\n    // The event selector is computed from the type signature of the struct in the event, similar to how one might type\n    // the constructor function. For example, given:\n    //\n    // struct Foo {\n    //   a: Field,\n    //   b: AztecAddress,\n    // }\n    //\n    // The signature will be \"Foo(Field,AztecAddress)\".\n    let event_name = s.name();\n    let args_signatures = s\n        .fields_as_written()\n        .map(|(_, typ): (Quoted, Type)| {\n            // signature_of_type can handle structs, so this supports nested structs\n            // FIXME: Field generics are not handled here!\n            signature_of_type(typ)\n        })\n        .join(quote {,});\n    let signature_quote = quote { $event_name($args_signatures) };\n    let (signature_str_quote, _) = signature_quote.as_str_quote();\n\n    let computation_quote = quote {\n        protocol_types::traits::ToField::to_field(protocol_types::abis::event_selector::EventSelector::from_signature($signature_str_quote))\n    };\n    unquote!(computation_quote)\n}\n\n/// Returns how many storage slots a type needs to reserve for itself. State variables must implement the Storage trait\n/// for slots to be allocated for them.\npub(crate) comptime fn get_storage_size(typ: Type) -> u32 {\n    // We create a type variable for the storage size. We can't simply read the value used in the implementation because\n    // it may not be a constant (e.g. N + 1). We then bind it to the implementation of the Storage trait.\n    let storage_size = std::meta::typ::fresh_type_variable();\n    assert(\n        typ.implements(quote { crate::state_vars::Storage<$storage_size> }.as_trait_constraint()),\n        f\"Attempted to fetch storage size, but {typ} does not implement the Storage trait\",\n    );\n\n    storage_size.as_constant().unwrap()\n}\n\npub(crate) comptime fn module_has_storage(m: Module) -> bool {\n    m.structs().any(|s: TypeDefinition| {\n        s.has_named_attribute(\"storage\") | s.has_named_attribute(\"storage_no_init\")\n    })\n}\n\npub(crate) comptime fn module_has_initializer(m: Module) -> bool {\n    m.functions().any(|f: FunctionDefinition| is_fn_initializer(f))\n}\n\npub(crate) comptime fn is_note(typ: Type) -> bool {\n    typ.as_data_type().map_or(false, |struc: (TypeDefinition, [Type])| {\n        let (def, _) = struc;\n        def.has_named_attribute(\"note\")\n            | def.has_named_attribute(\"partial_note\")\n            | def.has_named_attribute(\"custom_note\")\n    })\n}\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `noir-protocol-circuits/crates/types/src/meta/mod.nr`. We maintain separate\n/// copies because importing it here from there would cause the `target_trait` to be interpreted in the context\n/// of the protocol circuits types crate, making it impossible to compile code for traits from this crate\n/// (e.g. NoteType).\npub(crate) comptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ.get_trait_impl(trait_constraint).expect(f\"Type does not implement trait\").methods().filter(\n        |m| m.name() == target_method,\n    )[0]\n        .as_typed_expr()\n}\n"
    },
    "142": {
      "path": "/c/Users/emili/nargo/github.com/AztecProtocol/aztec-packages/v0.82.0/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::Serialize;\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, nonce: Field },\n//   Settled{ nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_nonce }\n            }\n        } else if maybe_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(nonce: Field) -> Self {\n        Self { nonce }\n    }\n\n    pub fn nonce(self) -> Field {\n        self.nonce\n    }\n}\n"
    },
    "145": {
      "path": "/c/Users/emili/nargo/github.com/AztecProtocol/aztec-packages/v0.82.0/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let nonce = retrieved_note.metadata.to_pending_previous_phase().nonce();\n\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "148": {
      "path": "/c/Users/emili/nargo/github.com/AztecProtocol/aztec-packages/v0.82.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "149": {
      "path": "/c/Users/emili/nargo/github.com/AztecProtocol/aztec-packages/v0.82.0/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
    },
    "151": {
      "path": "/c/Users/emili/nargo/github.com/AztecProtocol/aztec-packages/v0.82.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "152": {
      "path": "/c/Users/emili/nargo/github.com/AztecProtocol/aztec-packages/v0.82.0/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values) };\n}\n\npub unconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field]) {\n    let _ = store_in_execution_cache_oracle(values);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(storeInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field]) -> Field {}\n\n#[oracle(loadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "153": {
      "path": "/c/Users/emili/nargo/github.com/AztecProtocol/aztec-packages/v0.82.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_deployer_internal_avm(address) };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_class_id_internal_avm(address) };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address) };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "158": {
      "path": "/c/Users/emili/nargo/github.com/AztecProtocol/aztec-packages/v0.82.0/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(getKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "159": {
      "path": "/c/Users/emili/nargo/github.com/AztecProtocol/aztec-packages/v0.82.0/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(getPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] as bool } },\n        ivpk_m: IvpkM {\n            inner: Point { x: result[3], y: result[4], is_infinite: result[5] as bool },\n        },\n        ovpk_m: OvpkM {\n            inner: Point { x: result[6], y: result[7], is_infinite: result[8] as bool },\n        },\n        tpk_m: TpkM {\n            inner: Point { x: result[9], y: result[10], is_infinite: result[11] as bool },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    let point_array = multi_scalar_mul_array_return(points, scalars);\n    EmbeddedCurvePoint { x: point_array[0], y: point_array[1], is_infinite: point_array[2] as bool }\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> [Field; 3] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// This is a hack because returning an `EmbeddedCurvePoint` from a foreign function in brillig returns a [BrilligVariable::SingleAddr; 2] rather than BrilligVariable::BrilligArray\n// as is defined in the brillig bytecode format. This is a workaround which allows us to fix this without modifying the serialization format.\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    let x_coordinates_match = point1.x == point2.x;\n    let y_coordinates_match = point1.y == point2.y;\n    let double_predicate = (x_coordinates_match & y_coordinates_match);\n    let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n    let point1_1 = EmbeddedCurvePoint {\n        x: point1.x + (x_coordinates_match as Field),\n        y: point1.y,\n        is_infinite: x_coordinates_match,\n    };\n    // point1_1 is guaranteed to have a different abscissa than point2\n    let mut result = embedded_curve_add_unsafe(point1_1, point2);\n    result.is_infinite = x_coordinates_match;\n\n    // dbl if x_match, y_match\n    let double = embedded_curve_add_unsafe(point1, point1);\n    result = if double_predicate { double } else { result };\n\n    // infinity if x_match, !y_match\n    if point1.is_infinite {\n        result = point2;\n    }\n    if point2.is_infinite {\n        result = point1;\n    }\n    let mut result_is_infinity = infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n    result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n    result\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n) -> [Field; 3] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    embedded_curve_add_unsafe(point1, point2)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    let point_array = embedded_curve_add_array_return(point1, point2);\n    let x = point_array[0];\n    let y = point_array[1];\n\n    EmbeddedCurvePoint { x, y, is_infinite: false }\n}\n"
    },
    "161": {
      "path": "/c/Users/emili/nargo/github.com/AztecProtocol/aztec-packages/v0.82.0/noir-projects/aztec-nr/aztec/src/oracle/message_discovery.nr",
      "source": "use crate::discovery::private_notes::MAX_NOTE_PACKED_LEN;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_DATA_SIZE_IN_FIELDS},\n};\n\n/// Finds new notes that may have been sent to all registered accounts in PXE in the current contract and makes them\n/// available for later querying via the `get_notes` oracle.\npub unconstrained fn sync_notes() {\n    sync_notes_oracle();\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle() {}\n\n/// Informs PXE of a note's existence so that it can later be retrieved by the `getNotes` oracle. The note will be\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was successfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        packed_note,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\n/// is the data required in order to discover notes that are being delivered in a log.\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\n// log.\npub struct LogWithTxData {\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_DATA_SIZE_IN_FIELDS>,\n    pub tx_hash: Field,\n    /// The array of new note hashes created by `tx_hash`\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    /// The first nullifier created by `tx_hash`\n    pub first_nullifier_in_tx: Field,\n}\n\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\n/// the tag is the first field in the log's content. Returns `Option::none` if no such log exists. Throws if more than\n/// one log with that tag exists.\n/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.\n// TODO(#11627): handle multiple logs with the same tag.\n// TODO(#10273): improve contract siloing of logs, don't introduce an extra field.\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\n    get_log_by_tag_oracle(tag)\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n\n#[oracle(getLogByTag)]\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\n"
    },
    "163": {
      "path": "/c/Users/emili/nargo/github.com/AztecProtocol/aztec-packages/v0.82.0/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::{\n    note::{note_interface::NoteType, note_metadata::NoteMetadata, retrieved_note::RetrievedNote},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    indexed_tagging_secret::{INDEXED_TAGGING_SECRET_LENGTH, IndexedTaggingSecret},\n    traits::{Deserialize, FromField, Packable},\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {\n    // This wrapper exists to extract the ORACLE_RETURN_FIELD_LENGTH generic numeric param into a value and pass it to\n    // the oracle, so that it knows how big the return array must be.\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        ORACLE_RETURN_FIELD_LENGTH,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let MAX_NOTES: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    _placeholder_fields: [Field; ORACLE_RETURN_FIELD_LENGTH], // TODO: Compute this value automatically from MAX_NOTES\n) -> [Option<RetrievedNote<Note>>; MAX_NOTES]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let fields: [_; ORACLE_RETURN_FIELD_LENGTH] = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n\n    let mut opt_notes = [Option::none(); MAX_NOTES];\n    for i in 0..opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n\n            let maybe_nonce = fields[read_offset];\n            let maybe_note_hash_counter = fields[read_offset + 1] as u32;\n            let packed_note = array::subarray(fields, read_offset + 2);\n\n            let note = Note::unpack(packed_note);\n            let retrieved_note = RetrievedNote {\n                note,\n                contract_address,\n                metadata: NoteMetadata::from_raw_data(maybe_note_hash_counter != 0, maybe_nonce),\n            };\n\n            opt_notes[i] = Option::some(retrieved_note);\n        };\n    }\n    opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n/// Same as `get_indexed_tagging_secret_as_sender`, except it returns the derived tag, ready to be included in a log.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender(sender, recipient).compute_tag(recipient)\n}\n\n/// Returns the tagging secret for a given sender and recipient pair, siloed for the current contract address.\n/// Includes the last known index used to send a note tagged with this secret.\n/// For this to work, PXE must know the ivsk_m of the sender.\n/// For the recipient's side, only the address is needed.\npub unconstrained fn get_indexed_tagging_secret_as_sender(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) -> IndexedTaggingSecret {\n    let result = get_indexed_tagging_secret_as_sender_oracle(sender, recipient);\n    IndexedTaggingSecret::deserialize(result)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> [Field; INDEXED_TAGGING_SECRET_LENGTH] {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n"
    },
    "165": {
      "path": "/c/Users/emili/nargo/github.com/AztecProtocol/aztec-packages/v0.82.0/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "175": {
      "path": "/c/Users/emili/nargo/github.com/AztecProtocol/aztec-packages/v0.82.0/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UnconstrainedContext},\n    state_vars::storage::Storage,\n    utils::with_hash::WithHash,\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::Packable};\n\n/// Stores an immutable value in public state which can be read from public, private and unconstrained execution\n/// contexts.\n///\n/// Leverages `WithHash<T>` to enable efficient private reads of public storage. `WithHash` wrapper allows for\n/// efficient reads by verifying large values through a single hash check and then proving inclusion only of the hash\n/// in the public storage. This reduces the number of required tree inclusion proofs from O(M) to O(1).\n///\n/// This is valuable when T packs to multiple fields, as it maintains \"almost constant\" verification overhead\n/// regardless of the original data size.\n///\n/// # Optimizing private reads in your contract\n/// Given that reading T from public immutable in private has \"almost constant\" constraints cost for different sizes\n/// of T it is recommended to group multiple values into a single struct when they are being read together. This can\n/// typically be some kind of configuration set up during contract initialization. E.g.:\n///\n/// ```noir\n/// use dep::aztec::protocol_types::{address::AztecAddress, traits::Packable};\n/// use std::meta::derive;\n///\n/// #[derive(Eq, Packable)]\n/// pub struct Config \\{\n///     pub address_1: AztecAddress,\n///     pub value_1: u128,\n///     pub value_2: u64,\n///     ...\n/// }\n/// ```\n///\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\n/// `WithHash<T>` stores both the packed value (using N fields) and its hash (1 field), requiring N = M + 1 total\n/// fields.\nimpl<T, Context, let M: u32, let N: u32> Storage<N> for PublicImmutable<T, Context>\nwhere\n    WithHash<T, M>: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    // docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicImmutable<T, &mut PublicContext>\nwhere\n    T: Packable<T_PACKED_LEN> + Eq,\n{\n    // docs:start:public_immutable_struct_write\n    pub fn initialize(self, value: T) {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"PublicImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, WithHash::new(value));\n    }\n    // docs:end:public_immutable_struct_write\n\n    // Note that we don't access the context, but we do call oracles that are only available in public\n    // docs:start:public_immutable_struct_read\n    pub fn read(self) -> T {\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicImmutable<T, UnconstrainedContext>\nwhere\n    T: Packable<T_PACKED_LEN> + Eq,\n{\n    pub unconstrained fn read(self) -> T {\n        WithHash::unconstrained_public_storage_read(self.context, self.storage_slot)\n    }\n}\n\nimpl<T, let T_PACKED_LEN: u32> PublicImmutable<T, &mut PrivateContext>\nwhere\n    T: Packable<T_PACKED_LEN> + Eq,\n{\n    pub fn read(self) -> T {\n        WithHash::historical_public_storage_read(\n            self.context.get_block_header(),\n            self.context.this_address(),\n            self.storage_slot,\n        )\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "190": {
      "path": "/c/Users/emili/nargo/github.com/AztecProtocol/aztec-packages/v0.82.0/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "192": {
      "path": "/c/Users/emili/nargo/github.com/AztecProtocol/aztec-packages/v0.82.0/noir-projects/aztec-nr/aztec/src/utils/array/mod.nr",
      "source": "pub mod append;\npub mod collapse;\npub mod subarray;\npub mod subbvec;\n\npub use append::append;\npub use collapse::collapse;\npub use subarray::subarray;\npub use subbvec::subbvec;\n\n// This will eventually be replaced by `BoundedVec::for_each`, once that's implemented.\npub unconstrained fn for_each_in_bounded_vec<T, let MaxLen: u32, Env>(\n    vec: BoundedVec<T, MaxLen>,\n    f: fn[Env](T, u32) -> (),\n) {\n    for i in 0..vec.len() {\n        f(vec.get_unchecked(i), i);\n    }\n}\n"
    },
    "193": {
      "path": "/c/Users/emili/nargo/github.com/AztecProtocol/aztec-packages/v0.82.0/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "194": {
      "path": "/c/Users/emili/nargo/github.com/AztecProtocol/aztec-packages/v0.82.0/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "196": {
      "path": "/c/Users/emili/nargo/github.com/AztecProtocol/aztec-packages/v0.82.0/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "197": {
      "path": "/c/Users/emili/nargo/github.com/AztecProtocol/aztec-packages/v0.82.0/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "199": {
      "path": "/c/Users/emili/nargo/github.com/AztecProtocol/aztec-packages/v0.82.0/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "201": {
      "path": "/c/Users/emili/nargo/github.com/AztecProtocol/aztec-packages/v0.82.0/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "205": {
      "path": "/c/Users/emili/nargo/github.com/AztecProtocol/aztec-packages/v0.82.0/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UnconstrainedContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    address::AztecAddress, block_header::BlockHeader, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `N` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `N`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let N: u32> {\n    value: T,\n    packed: [Field; N],\n    hash: Field,\n}\n\nimpl<T, let N: u32> WithHash<T, N>\nwhere\n    T: Packable<N> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn unconstrained_public_storage_read(\n        context: UnconstrainedContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number as u32;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + N as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\nimpl<T, let N: u32> Packable<N + 1> for WithHash<T, N>\nwhere\n    T: Packable<N>,\n{\n    fn pack(self) -> [Field; N + 1] {\n        let mut result: [Field; N + 1] = std::mem::zeroed();\n        for i in 0..N {\n            result[i] = self.packed[i];\n        }\n        result[N] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; N + 1]) -> Self {\n        let mut value_packed: [Field; N] = std::mem::zeroed();\n        for i in 0..N {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[N];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        oracle::random::random,\n        test::{\n            helpers::{cheatcodes, test_environment::TestEnvironment},\n            mocks::mock_struct::MockStruct,\n        },\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::{mem, test::OracleMock};\n\n    global storage_slot: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n\n        // We should get zeroed value\n        let expected: MockStruct = mem::zeroed();\n        assert_eq(result, expected);\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        // We write the value with hash to storage\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            storage_slot,\n            value_with_hash.pack(),\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n\n        assert_eq(result, value);\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn test_bad_hint_uninitialized_value() {\n        let mut env = TestEnvironment::new();\n\n        env.advance_block_to(6);\n\n        let value_packed = MockStruct { a: 1, b: 1 }.pack();\n\n        let block_header = env.private().historical_header;\n        let address = env.contract_address();\n\n        // Mock the oracle to return a non-zero hint/packed value\n        let _ = OracleMock::mock(\"storageRead\")\n            .with_params((\n                address.to_field(), storage_slot, block_header.global_variables.block_number as u32,\n                value_packed.len(),\n            ))\n            .returns(value_packed)\n            .times(1);\n\n        // This should revert because the hint value is non-zero and the hash is zero (default value of storage)\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            block_header,\n            address,\n            storage_slot,\n        );\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn test_bad_hint_initialized_value() {\n        let mut env = TestEnvironment::new();\n\n        let value_packed = MockStruct { a: 5, b: 3 }.pack();\n\n        // We write the value to storage\n        cheatcodes::direct_storage_write(env.contract_address(), storage_slot, value_packed);\n\n        // Now we write incorrect hash to the hash storage slot\n        let incorrect_hash = random();\n        let hash_storage_slot = storage_slot + (value_packed.len() as Field);\n        cheatcodes::direct_storage_write(\n            env.contract_address(),\n            hash_storage_slot,\n            [incorrect_hash],\n        );\n\n        // We advance block by 1 because env.private() currently returns context at latest_block - 1\n        env.advance_block_by(1);\n\n        let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n            env.private().historical_header,\n            env.contract_address(),\n            storage_slot,\n        );\n    }\n}\n"
    },
    "223": {
      "path": "/c/Users/emili/nargo/github.com/AztecProtocol/aztec-packages/v0.82.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "24": {
      "path": "std/hash/poseidon2.nr",
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "266": {
      "path": "/c/Users/emili/nargo/github.com/AztecProtocol/aztec-packages/v0.82.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"
    },
    "283": {
      "path": "/c/Users/emili/nargo/github.com/AztecProtocol/aztec-packages/v0.82.0/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "284": {
      "path": "/c/Users/emili/nargo/github.com/AztecProtocol/aztec-packages/v0.82.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{\n        arrays::{array_concat, unsafe_padded_array_length},\n        field::{field_from_bytes, field_from_bytes_32_trunc},\n    },\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(contract_class_log: ContractClassLog) -> Field {\n    let array = contract_class_log.log.fields;\n    // Safety: The below length is constrained in the base rollup.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    if length == 0 {\n        0\n    } else {\n        poseidon2_hash(array)\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as std::hash::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = std::hash::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = std::hash::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "298": {
      "path": "/c/Users/emili/nargo/github.com/AztecProtocol/aztec-packages/v0.82.0/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `omit`: A list of field names (as `Quoted`) to be excluded from the serialized output.\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, &[], false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, &[], false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], &[], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, &[], false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with Omitted Field and packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// Serializing while omitting `value2`:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, MyStruct, &[quote { self.value2 }], true)\n/// // Returns:\n/// // ([`value_packed[0]`], [`let value_packed = self.value.pack()`])\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    omit: [Quoted],\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // Proceed if none of the omit rules omits this name\n    if !omit.any(|to_omit| to_omit == name) {\n        // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n        let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n        let packable_constraint =\n            quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n        if (should_pack & typ.implements(packable_constraint)) {\n            // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n            // method, add the resulting field array to `aux_vars` and each field to `fields`.\n            let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n            // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n            let name_at_one_token = collapse_to_one_token(name);\n            let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n            // We add the individual fields to the fields array\n            let pack_method = get_trait_impl_method(\n                typ,\n                quote { crate::traits::Packable<$packed_len> },\n                quote { pack },\n            );\n            let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n            for i in 0..packed_len {\n                fields = fields.push_back(quote { $packed_struct_name[$i] });\n            }\n\n            // We add the new auxiliary variable to the aux_vars array\n            aux_vars = aux_vars.push_back(packed_struct);\n        } else if typ.is_field() {\n            // For field we just add the value to fields\n            fields = fields.push_back(name);\n        } else if typ.as_integer().is_some() | typ.is_bool() {\n            // For integer and bool we just cast to Field and add the value to fields\n            fields = fields.push_back(quote { $name as Field });\n        } else if typ.as_data_type().is_some() {\n            // For struct we pref\n            let nested_struct = typ.as_data_type().unwrap();\n            let params = nested_struct.0.fields(nested_struct.1);\n            let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\n                let maybe_prefixed_name = if name == quote {} {\n                    // Triggered when the param name is of a value available in the current scope (e.g. a function\n                    // argument) --> then we don't prefix the name with anything.\n                    param_name\n                } else {\n                    // Triggered when we want to prefix the param name with the `name` from function input. This\n                    // can typically be `self` when implementing a method on a struct.\n                    quote { $name.$param_name }\n                };\n                generate_serialize_to_fields(\n                    quote {$maybe_prefixed_name},\n                    param_type,\n                    omit,\n                    should_pack,\n                )\n            });\n            let struct_flattened_fields = struct_flattened.fold(\n                &[],\n                |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n            );\n            let struct_flattened_aux_vars = struct_flattened.fold(\n                &[],\n                |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n            );\n            fields = fields.append(struct_flattened_fields);\n            aux_vars = aux_vars.append(struct_flattened_aux_vars);\n        } else if typ.as_array().is_some() {\n            // For array we recursively call `generate_serialize_to_fields(...)` for each element\n            let (element_type, array_len) = typ.as_array().unwrap();\n            let array_len = array_len.as_constant().unwrap();\n            for i in 0..array_len {\n                let (element_fields, element_aux_vars) = generate_serialize_to_fields(\n                    quote { $name[$i] },\n                    element_type,\n                    omit,\n                    should_pack,\n                );\n                fields = fields.append(element_fields);\n                aux_vars = aux_vars.append(element_aux_vars);\n            }\n        } else if typ.as_str().is_some() {\n            // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n            // then we add each byte to fields as a Field\n            let length_type = typ.as_str().unwrap();\n            let str_len = length_type.as_constant().unwrap();\n            let as_member = name.as_expr().unwrap().as_member_access();\n            let var_name = if as_member.is_some() {\n                as_member.unwrap().1\n            } else {\n                name\n            };\n            let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n            let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n            for i in 0..str_len {\n                fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n            }\n            aux_vars = aux_vars.push_back(as_bytes);\n        } else {\n            panic(\n                f\"Unsupported type for serialization of argument {name} and type {typ}\",\n            )\n        }\n    }\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, &[], false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    quote {\n        impl Serialize<$serialized_len> for $typ {\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, &[], false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) =\n        generate_serialize_to_fields(quote { self }, typ, &[], packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n"
    },
    "300": {
      "path": "/c/Users/emili/nargo/github.com/AztecProtocol/aztec-packages/v0.82.0/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\nimpl Serialize<POINT_LENGTH> for Point {\n    fn serialize(self: Self) -> [Field; POINT_LENGTH] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize<POINT_LENGTH> for Point {\n    fn deserialize(serialized: [Field; POINT_LENGTH]) -> Point {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] as bool }\n    }\n}\n// TODO(#11356): use compact representation here.\nimpl Packable<POINT_LENGTH> for Point {\n    fn pack(self) -> [Field; POINT_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; POINT_LENGTH]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "301": {
      "path": "/c/Users/emili/nargo/github.com/AztecProtocol/aztec-packages/v0.82.0/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "310": {
      "path": "/c/Users/emili/nargo/github.com/AztecProtocol/aztec-packages/v0.82.0/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::POINT_LENGTH,\n    traits::{Deserialize, Hash, Serialize, ToField},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::default::Default;\n\npub global PUBLIC_KEYS_LENGTH: u32 = 12;\n\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for NpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for IvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for OvpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nimpl Serialize<POINT_LENGTH> for TpkM {\n    fn serialize(self) -> [Field; POINT_LENGTH] {\n        self.inner.serialize()\n    }\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl Eq for PublicKeys {\n    fn eq(self, other: PublicKeys) -> bool {\n        (self.npk_m.inner == other.npk_m.inner)\n            & (self.ivpk_m.inner == other.ivpk_m.inner)\n            & (self.ovpk_m.inner == other.ovpk_m.inner)\n            & (self.tpk_m.inner == other.tpk_m.inner)\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\nimpl Serialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn serialize(self) -> [Field; PUBLIC_KEYS_LENGTH] {\n        [\n            self.npk_m.inner.x,\n            self.npk_m.inner.y,\n            self.npk_m.inner.is_infinite as Field,\n            self.ivpk_m.inner.x,\n            self.ivpk_m.inner.y,\n            self.ivpk_m.inner.is_infinite as Field,\n            self.ovpk_m.inner.x,\n            self.ovpk_m.inner.y,\n            self.ovpk_m.inner.is_infinite as Field,\n            self.tpk_m.inner.x,\n            self.tpk_m.inner.y,\n            self.tpk_m.inner.is_infinite as Field,\n        ]\n    }\n}\n\nimpl Deserialize<PUBLIC_KEYS_LENGTH> for PublicKeys {\n    fn deserialize(serialized: [Field; PUBLIC_KEYS_LENGTH]) -> PublicKeys {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point {\n                    x: serialized[0],\n                    y: serialized[1],\n                    is_infinite: serialized[2] as bool,\n                },\n            },\n            ivpk_m: IvpkM {\n                inner: Point {\n                    x: serialized[3],\n                    y: serialized[4],\n                    is_infinite: serialized[5] as bool,\n                },\n            },\n            ovpk_m: OvpkM {\n                inner: Point {\n                    x: serialized[6],\n                    y: serialized[7],\n                    is_infinite: serialized[8] as bool,\n                },\n            },\n            tpk_m: TpkM {\n                inner: Point {\n                    x: serialized[9],\n                    y: serialized[10],\n                    is_infinite: serialized[11] as bool,\n                },\n            },\n        }\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[test]\nunconstrained fn compute_public_keys_hash() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let actual = keys.hash();\n    let expected_public_keys_hash =\n        0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n    assert(actual.to_field() == expected_public_keys_hash);\n}\n\n#[test]\nunconstrained fn compute_default_hash() {\n    let keys = PublicKeys::default();\n\n    let actual = keys.hash();\n    let test_data_default_hash = 0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n    assert(actual.to_field() == test_data_default_hash);\n}\n\n#[test]\nunconstrained fn test_public_keys_serialization() {\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n        ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n        ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n        tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n    };\n\n    let serialized = keys.serialize();\n    let deserialized = PublicKeys::deserialize(serialized);\n\n    assert_eq(keys.npk_m.inner.x, deserialized.npk_m.inner.x);\n    assert_eq(keys.npk_m.inner.y, deserialized.npk_m.inner.y);\n    assert_eq(keys.ivpk_m.inner.x, deserialized.ivpk_m.inner.x);\n    assert_eq(keys.ivpk_m.inner.y, deserialized.ivpk_m.inner.y);\n    assert_eq(keys.ovpk_m.inner.x, deserialized.ovpk_m.inner.x);\n    assert_eq(keys.ovpk_m.inner.y, deserialized.ovpk_m.inner.y);\n    assert_eq(keys.tpk_m.inner.x, deserialized.tpk_m.inner.x);\n    assert_eq(keys.tpk_m.inner.y, deserialized.tpk_m.inner.y);\n}\n"
    },
    "335": {
      "path": "/c/Users/emili/nargo/github.com/AztecProtocol/aztec-packages/v0.82.0/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n}\n\nimpl<T> Empty for Option<T> {\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Type Parameters\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize<N> for str<N> {\n///     fn serialize(self) -> [Field; N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Type Parameters\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Deserialize<N> for str<N> {\n///     fn deserialize(fields: [Field; N]) -> Self {\n///         str<N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Type Parameters\n/// * `N` - The length of the Field array, known at compile time.\n#[derive_via(derive_packable)]\npub trait Packable<let N: u32> {\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n"
    },
    "339": {
      "path": "/c/Users/emili/nargo/github.com/AztecProtocol/aztec-packages/v0.82.0/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "340": {
      "path": "/c/Users/emili/nargo/github.com/AztecProtocol/aztec-packages/v0.82.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "356": {
      "path": "/c/Users/emili/nargo/github.com/AztecProtocol/aztec-packages/v0.82.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"
    },
    "359": {
      "path": "/c/Users/emili/nargo/github.com/AztecProtocol/aztec-packages/v0.82.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "365": {
      "path": "/c/Users/emili/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "392": {
      "path": "/c/Users/emili/nargo/github.com/AztecProtocol/aztec-packages/v0.82.0/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    encrypted_logs::log_assembly_strategies::default_aes128,\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER},\n        hash::poseidon2_hash_with_separator,\n        traits::{Deserialize, Hash, Packable, Serialize, ToField},\n        utils::arrays::array_concat,\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[custom_note]\n#[derive(Eq, Serialize)]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// The returned `PartialUintNote` value must be sent to public execution via a secure channel, since it is not\n    /// possible to verify the integrity of its contents due to it hiding information. The recommended ways to do this\n    /// are to retrieve it from public storage, or to receive it in an internal public function call.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` from `sender` so that they can\n    /// discover the note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        sender: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n\n        // TODO: we're abusing the note encoding scheme by computing the log for a fake note type with such a note type\n        // id that the recipient will realize that these are the private fields of a partial note. Ideally we'd not rely\n        // on this crude mechanism and we'd instead compute it as a proper event log. However, given the current state\n        // of the log library it's far easier to do it this way.\n        let encrypted_log = default_aes128::note::compute_log(\n            *context,\n            private_log_content,\n            storage_slot,\n            recipient,\n            sender,\n        );\n        context.emit_private_log(encrypted_log);\n\n        PartialUintNote { commitment }\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            array_concat(self.pack(), [storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct PrivateUintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for PrivateUintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        // We abuse the fact that note type ids are 7 bits long to use the 8th bit indicate the log corresponds to a\n        // partial note. Ideally we'd use proper events with selectors, but those are not handled well at the moment.\n        UintNote::get_id() + 128\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nimpl PartialUintNote {\n    pub fn commitment(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, value: u128, context: &mut PublicContext) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; 2] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, PrivateUintPartialNotePrivateLogContent, UintNote,\n        UintPartialNotePrivateContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{\n            address::AztecAddress,\n            traits::{FromField, Packable},\n            utils::arrays::array_concat,\n        },\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n        let partial_note = PartialUintNote { commitment };\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(\n            array_concat(private_log_without_public_tag, public_log_without_tag),\n            note.pack(),\n        );\n    }\n}\n"
    },
    "46": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "47": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "50": {
      "path": "std/slice.nr",
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n}\n"
    },
    "56": {
      "path": "/c/Users/emili/Core-Contracts/src/main.nr",
      "source": "use dep::aztec::macros::aztec;\r\n\r\n\r\n\r\n\r\n#[aztec]\r\npub contract Bundler {\r\n    use std::{meta::derive, ops::{Add, Sub}};\r\n    use token::Token;\r\n\r\n    use dep::aztec::{\r\n        context::{PrivateCallInterface, PrivateContext},\r\n        encrypted_logs::log_assembly_strategies::default_aes128::{\r\n            event::encode_and_encrypt_event_unconstrained,\r\n            note::{encode_and_encrypt_note, encode_and_encrypt_note_unconstrained},\r\n        },\r\n        event::event_interface::EventInterface,\r\n        macros::{\r\n            events::event,\r\n            functions::{initializer, internal, private, public, view},\r\n            storage::storage,\r\n        },\r\n        prelude::{AztecAddress, Map, PublicContext, PublicImmutable, PublicMutable},\r\n        protocol_types::traits::Serialize,\r\n    };\r\n    \r\n    use dep::authwit::auth::{\r\n        assert_current_call_valid_authwit, \r\n        assert_current_call_valid_authwit_public,\r\n        compute_authwit_nullifier,\r\n    };\r\n\r\n    #[storage]\r\n    struct Storage<Context> {\r\n        admin: PublicImmutable<AztecAddress, Context>,\r\n    }\r\n\r\n    #[public]\r\n    #[initializer]\r\n    fn constructor(admin: AztecAddress) {\r\n        assert(!admin.is_zero(), \"invalid admin address\");\r\n    \r\n        storage.admin.initialize(admin);\r\n    }\r\n\r\n\r\n    /// Send n Stable tokens and m Reward tokens to an address (public version)\r\n    /// \r\n    /// This function bundles two public token transfers into a single transaction\r\n    #[public]\r\n    fn send_tokens_public(\r\n        to: AztecAddress, \r\n        reward_token: AztecAddress,\r\n        stable_token: AztecAddress,\r\n        stable_amount: u128, \r\n        reward_amount: u128\r\n    ) {\r\n        let from = context.msg_sender();\r\n        let nonce = 0 as Field; // No AuthWit, sending as self\r\n        \r\n        // Send stable tokens\r\n        if (stable_amount > 0) {\r\n            Token::at(stable_token)\r\n                .transfer_in_public(from, to, stable_amount, nonce)\r\n                .call(&mut context);\r\n        }\r\n        \r\n        // Send reward tokens\r\n        if (reward_amount > 0) {\r\n            Token::at(reward_token)\r\n                .transfer_in_public(from, to, reward_amount, nonce)\r\n                .call(&mut context);\r\n        }\r\n    }\r\n    \r\n    /// Send n Stable tokens and m Reward tokens to an address (private version)\r\n    /// \r\n    /// This function bundles two private token transfers into a single transaction\r\n    #[private]\r\n    fn send_tokens_private(\r\n        to: AztecAddress, \r\n        reward_token: AztecAddress,\r\n        stable_token: AztecAddress,\r\n        stable_amount: u128, \r\n        reward_amount: u128\r\n    ) {\r\n        let from = context.msg_sender();\r\n        let nonce = 0 as Field; // No AuthWit, sending as self\r\n        \r\n        // Send stable tokens\r\n        if (stable_amount > 0) {\r\n            Token::at(stable_token)\r\n                .transfer_in_private(from, to, stable_amount, nonce)\r\n                .call(&mut context);\r\n        }\r\n        \r\n        // Send reward tokens\r\n        if (reward_amount > 0) {\r\n            Token::at(reward_token)\r\n                .transfer_in_private(from, to, reward_amount, nonce)\r\n                .call(&mut context);\r\n        }\r\n    }\r\n    \r\n    /// Pay oneself Stable tokens from a given address using AuthWit, and send Reward tokens to that address\r\n    /// Public version of the function for public token balances\r\n    #[public]\r\n    fn exchange_tokens_public(\r\n        from: AztecAddress, \r\n        stable_token: AztecAddress,\r\n        reward_token: AztecAddress,\r\n        stable_amount: u128, \r\n        reward_amount: u128,\r\n        nonce: Field\r\n    ) {\r\n        let to = context.msg_sender(); // The caller will receive the stable tokens\r\n        \r\n        // Take stable tokens from 'from' to 'to' (caller) using AuthWit\r\n        if (!from.eq(to)) {\r\n            // If sender is not the caller, we need to validate authwit\r\n            assert_current_call_valid_authwit_public(&mut context, from);\r\n        } else {\r\n            assert(nonce == 0, \"invalid nonce\");\r\n        }\r\n        \r\n        // Pull stable tokens from 'from' address to caller\r\n        if (stable_amount > 0) {\r\n            Token::at(stable_token)\r\n                .transfer_in_public(from, to, stable_amount, nonce)\r\n                .call(&mut context);\r\n        }\r\n        \r\n        // Send reward tokens from caller to 'from' address\r\n        if (reward_amount > 0) {\r\n            let reward_nonce = 0 as Field; // No AuthWit needed as caller is sending their own tokens\r\n            Token::at(reward_token)\r\n                .transfer_in_public(to, from, reward_amount, reward_nonce)\r\n                .call(&mut context);\r\n        }\r\n    }\r\n    \r\n    /// Pay oneself Stable tokens from a given address using AuthWit, and send Reward tokens to that address\r\n    /// Private version of the function for private token balances\r\n    #[private]\r\n    fn exchange_tokens_private(\r\n        from: AztecAddress, \r\n        stable: AztecAddress,\r\n        reward: AztecAddress,\r\n        stable_amount: u128, \r\n        reward_amount: u128,\r\n        nonce: Field\r\n    ) {\r\n        let to = context.msg_sender(); // The caller will receive the stable tokens\r\n        \r\n        // Take stable tokens from 'from' to 'to' (caller) using AuthWit\r\n        if (!from.eq(to)) {\r\n            // If sender is not the caller, we need to validate authwit\r\n            if (stable_amount > 0) {\r\n                assert_current_call_valid_authwit(&mut context, from);\r\n            }\r\n        } else {\r\n            assert(nonce == 0, \"invalid nonce\");\r\n        }\r\n        \r\n        // Pull stable tokens from 'from' address to caller\r\n        if (stable_amount > 0) {\r\n            Token::at(stable)\r\n                .transfer_in_private(from, to, stable_amount, nonce)\r\n                .call(&mut context);\r\n        }\r\n        \r\n        // Send reward tokens from caller to 'from' address\r\n        if (reward_amount > 0) {\r\n            let reward_nonce = 0 as Field; // No AuthWit needed as caller is sending their own tokens\r\n            Token::at(reward)\r\n                .transfer_in_private(to, from, reward_amount, reward_nonce)\r\n                .call(&mut context);\r\n        }\r\n    }\r\n    \r\n    /// Cancel an authentication witness for the stable token\r\n    #[private]\r\n    fn cancel_stable_authwit(inner_hash: Field) {\r\n        let on_behalf_of = context.msg_sender();\r\n        let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\r\n        context.push_nullifier(nullifier);\r\n    }\r\n    \r\n    /// Cancel an authentication witness for the reward token\r\n    #[private]\r\n    fn cancel_reward_authwit(inner_hash: Field) {\r\n        let on_behalf_of = context.msg_sender();\r\n        let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\r\n        context.push_nullifier(nullifier);\r\n    }\r\n\r\n    \r\n}"
    },
    "59": {
      "path": "/c/Users/emili/nargo/github.com/AztecProtocol/aztec-packages/v0.82.0/noir-projects/aztec-nr/authwit/src/auth.nr",
      "source": "use dep::aztec::{context::{gas::GasOpts, PrivateContext, PublicContext}, hash::hash_args_array};\nuse dep::aztec::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    constants::{\n        CANONICAL_AUTH_REGISTRY_ADDRESS, GENERATOR_INDEX__AUTHWIT_INNER,\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER, GENERATOR_INDEX__AUTHWIT_OUTER,\n    },\n    hash::poseidon2_hash_with_separator,\n    traits::ToField,\n};\n\n/**\n * Authenticaion witness helper library\n *\n * Authentication Witness is a scheme for authenticating actions on Aztec, so users can allow third-parties\n * (e.g. protocols or other users) to execute an action on their behalf.\n *\n * This library provides helper functions to manage such witnesses.\n * The authentication witness, is some \"witness\" (data) that authenticates a `message_hash`.\n * The simplest example of an authentication witness, is a signature. The signature is the \"evidence\",\n * that the signer has seen the message, agrees with it, and has allowed it.\n * It does not need to be a signature. It could be any kind of \"proof\" that the message is allowed.\n * Another proof could be knowing some kind of secret, or having some kind of \"token\" that allows the message.\n *\n * The `message_hash` is a hash of the following structure:\n * hash(consumer, chain_id, version, inner_hash)\n * - consumer: the address of the contract that is \"consuming\" the message,\n * - chain_id: the chain id of the chain that the message is being consumed on,\n * - version: the version of the chain that the message is being consumed on,\n * - inner_hash: the hash of the \"inner\" message that is being consumed, this is the \"actual\" message or action.\n *\n * While the `inner_hash` could be anything, such as showing you signed a specific message, it will often be\n * a hash of the \"action\" to approve, along with who made the call. As part of this library, we provide a few\n * helper functions to deal with such messages.\n *\n * For example, we provide helper function that is used for checking that the message is an encoding of the current call.\n * This can be used to let some contract \"allow\" another contract to act on its behalf, as long as it can\n * show that it is acting on behalf of the contract.\n *\n * If we take a case of allowing a contract to transfer tokens on behalf of an account, the `inner_hash` can be\n * derived as:\n * inner_hash = hash(caller, \"transfer\", hash(to, amount))\n *\n * Where the `caller` would be the address of the contract that is trying to transfer the tokens, and `to` and `amount`\n * the arguments for the transfer.\n *\n * Note that we have both a `caller` and a `consumer`, the `consumer` will be the contract that is consuming the message,\n * in the case of the transfer, it would be the `Token` contract itself, while the caller, will be the actor that is\n * allowed to transfer the tokens.\n *\n *\n * The authentication mechanism works differently in public and private contexts. In private, we recall that everything\n * is executed on the user's device, so we can use `oracles` to \"ask\" the user (not contract) for information. In public\n * we cannot do this, since it is executed by the sequencer (someone else). Therefore we can instead use a \"registry\"\n * to store the messages that we have approved.\n *\n * A simple example would be a \"token\" that is being \"pulled\" from one account into another. We will first outline\n * how this would look in private, and then in public later.\n *\n * Say that a user `Alice` wants to deposit some tokens into a DeFi protocol (say a DEX).\n * `Alice` would make a `deposit` transaction, that she is executing using her account contract.\n * The account would call the `DeFi` contract to execute `deposit`, which would try to pull funds from the `Token`\n * contract. Since the `DeFi` contract is trying to pull funds from an account that is not its own, it needs to\n * convince the `Token` contract that it is allowed to do so.\n *\n * This is where the authentication witness comes in The `Token` contract computes a `message_hash` from the\n * `transfer` call, and then asks `Alice Account` contract to verify that the `DeFi` contract is allowed to\n * execute that call.\n *\n * `Alice Account` contract can then ask `Alice` if she wants to allow the `DeFi` contract to pull funds from her\n * account. If she does, she will sign the `message_hash` and return the signature to the `Alice Account` which\n * will validate it and return success to the `Token` contract which will then allow the `DeFi` contract to pull\n * funds from `Alice`.\n *\n * To ensure that the same \"approval\" cannot be used multiple times, we also compute a `nullifier` for the\n * authentication witness, and emit it from the `Token` contract (consumer).\n *\n * Note that we can do this flow as we are in private were we can do oracle calls out from contracts.\n *\n *\n *  Person          Contract              Contract               Contract\n *  Alice          Alice Account          Token                   DeFi\n *   |                  |                  |                      |\n *   | Defi.deposit(Token, 1000)           |                      |\n *   |----------------->|                  |                      |\n *   |                  | deposit(Token, 1000)                    |\n *   |                  |---------------------------------------->|\n *   |                  |                  |                      |\n *   |                  |                  | transfer(Alice, Defi, 1000)\n *   |                  |                  |<---------------------|\n *   |                  |                  |                      |\n *   |                  | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |<-----------------|                      |\n *   |                  |                  |                      |\n *   | Please give me AuthWit for DeFi     |                      |\n *   | calling transfer(Alice, Defi, 1000) |                      |\n *   |<-----------------|                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   | AuthWit for transfer(Alice, Defi, 1000)                    |\n *   |----------------->|                  |                      |\n *   |                  | AuthWit validity |                      |\n *   |                  |----------------->|                      |\n *   |                  |                  |                      |\n *   |                  |       throw if invalid AuthWit          |\n *   |                  |                  |                      |\n *   |                  |       emit AuthWit nullifier            |\n *   |                  |                  |                      |\n *   |                  |       transfer(Alice, Defi, 1000)       |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  | success              |\n *   |                  |                  |--------------------->|\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |           deposit(Token, 1000)\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *\n *\n * If we instead were in public, we cannot do the same flow. Instead we would use an authentication registry to store\n * the messages that we have approved.\n *\n * To approve a message, `Alice Account` can make a `set_authorized` call to the registry, to set a `message_hash`\n * as authorized. This is essentially a mapping from `message_hash` to `true` for `Alice Contract`. Every account\n * has its own map in the registry, so `Alice` cannot approve a message for `Bob`.\n *\n * The `Token` contract can then try to \"spend\" the approval by calling `consume` on the registry. If the message\n * was approved, the value is updated to `false`, and we return the success flag. For more information on the\n * registry, see `main.nr` in `auth_registry_contract`.\n *\n * Person          Contract              Contract            Contract               Contract\n * Alice          Alice Account          Registry             Token                   DeFi\n *   |                  |                    |                   |                      |\n *   | Registry.set_authorized(..., true)    |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | set_authorized(..., true)              |                      |\n *   |                  |------------------->|                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |         set authorized to true         |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   | Defi.deposit(Token, 1000)             |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | deposit(Token, 1000)                   |                      |\n *   |                  |-------------------------------------------------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |              transfer(Alice, Defi, 1000) |\n *   |                  |                    |                   |<---------------------|\n *   |                  |                    |                   |                      |\n *   |                  |                    | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |                    |<------------------|                      |\n *   |                  |                    |                   |                      |\n *   |                  |          throw if invalid AuthWit      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |           set authorized to false      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    | AuthWit validity  |                      |\n *   |                  |                    |------------------>|                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | transfer(Alice, Defi, 1000)\n *   |                  |                    |                   |<-------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | success              |\n *   |                  |                    |                   |--------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |     deposit(Token, 1000)\n *   |                  |                    |                   |                      |\n *\n *\n * --- FAQ ---\n * Q:   Why are we using a success flag of `poseidon2_hash_bytes(\"IS_VALID()\")` instead of just returning a boolean?\n * A:   We want to make sure that we don't accidentally return `true` if there is a collision in the function selector.\n *      By returning a hash of `IS_VALID()`, it becomes very unlikely that there is both a collision and we return\n *      a success flag.\n *\n * Q:   Why are we using static calls?\n * A:   We are using static calls to ensure that the account contract cannot re-enter. If it was a normal call, it\n *      could make a new call and do a re-entry attack. Using a static ensures that it cannot update any state.\n *\n * Q:   Would it not be cheaper to use a nullifier instead of updating state in public?\n * A:   At a quick glance, a public state update + nullifier is 96 bytes, but two state updates are 128, so it would be\n *      cheaper to use a nullifier, if this is the way it would always be done. However, if both the approval and the\n *      consumption is done in the same transaction, then we will be able to squash the updates (only final tx state diff is posted to DA), and now it is cheaper.\n *\n * Q:   Why is the chain id and the version part of the message hash?\n * A:   The chain id and the version is part of the message hash to ensure that the message is only valid on a specific\n *      chain to avoid a case where the same message could be used across multiple chains.\n */\n\npub global IS_VALID_SELECTOR: Field = 0x47dacd73; // 4 last bytes of poseidon2_hash_bytes(\"IS_VALID()\")\n\n/**\n * Assert that `on_behalf_of` has authorized the current call with a valid authentication witness\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit\npub fn assert_current_call_valid_authwit(context: &mut PrivateContext, on_behalf_of: AztecAddress) {\n    let inner_hash = compute_inner_authwit_hash([\n        context.msg_sender().to_field(),\n        context.selector().to_field(),\n        context.args_hash,\n    ]);\n    assert_inner_hash_valid_authwit(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit\n\n/**\n * Assert that a specific `inner_hash` is valid for the `on_behalf_of` address\n *\n * Used as an internal function for `assert_current_call_valid_authwit` and can be used as a standalone function when\n * the `inner_hash` is from a different source, e.g., say a block of text etc.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n * @param inner_hash The hash of the message to authorize\n */\npub fn assert_inner_hash_valid_authwit(\n    context: &mut PrivateContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    // We perform a static call here and not a standard one to ensure that the account contract cannot re-enter.\n    let result: Field = context\n        .static_call_private_function(\n            on_behalf_of,\n            comptime { FunctionSelector::from_signature(\"verify_private_authwit(Field)\") },\n            [inner_hash],\n        )\n        .get_preimage();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n    // Compute the nullifier, similar computation to the outer hash, but without the chain_id and version.\n    // Those should already be handled in the verification, so we just need something to nullify, that allows the same inner_hash for multiple actors.\n    let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n    context.push_nullifier(nullifier);\n}\n\n/**\n * Assert that `on_behalf_of` has authorized the current call in the authentication registry\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit_public\npub unconstrained fn assert_current_call_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n) {\n    let inner_hash = compute_inner_authwit_hash([\n        (*context).msg_sender().to_field(),\n        (*context).selector().to_field(),\n        (*context).get_args_hash(),\n    ]);\n    assert_inner_hash_valid_authwit_public(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit_public\n\n/**\n * Assert that `on_behalf_of` has authorized a specific `inner_hash` in the authentication registry\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that has allegedly authorized the `inner_hash`\n */\npub unconstrained fn assert_inner_hash_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    let results: [Field] = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"consume((Field),Field)\") },\n        [on_behalf_of.to_field(), inner_hash].as_slice(),\n        GasOpts::default(),\n    );\n    assert(results.len() == 1, \"Invalid response from registry\");\n    assert(results[0] == IS_VALID_SELECTOR, \"Message not authorized by account\");\n}\n\n/**\n * Compute the `message_hash` from a function call to be used by an authentication witness\n *\n * Useful for when you need a non-account contract to approve during execution. For example if you need a contract\n * to make a call to nested contract, e.g., contract A wants to exit token T to L1 using bridge B, so it needs to allow\n * B to transfer T on its behalf.\n *\n * @param caller The address of the contract that is calling the function, in the example above, this would be B\n * @param consumer The address of the contract that is consuming the message, in the example above, this would be T\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param selector The function selector of the function that is being called\n * @param args The arguments of the function that is being called\n */\n// docs:start:compute_authwit_message_hash_from_call\npub fn compute_authwit_message_hash_from_call<let N: u32>(\n    caller: AztecAddress,\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    selector: FunctionSelector,\n    args: [Field; N],\n) -> Field {\n    let args_hash = hash_args_array(args);\n    let inner_hash =\n        compute_inner_authwit_hash([caller.to_field(), selector.to_field(), args_hash]);\n    compute_authwit_message_hash(consumer, chain_id, version, inner_hash)\n}\n// docs:end:compute_authwit_message_hash_from_call\n\n/**\n * Computes the `inner_hash` of the authentication witness\n *\n * This is used internally, but also useful in cases where you want to compute the `inner_hash` for a specific message\n * that is not necessarily a call, but just some \"bytes\" or text.\n *\n * @param args The arguments to hash\n */\npub fn compute_inner_authwit_hash<let N: u32>(args: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(args, GENERATOR_INDEX__AUTHWIT_INNER)\n}\n\n/**\n * Computes the `authwit_nullifier` for a specific `on_behalf_of` and `inner_hash`\n *\n * Using the `on_behalf_of` and the `inner_hash` to ensure that the nullifier is siloed for a specific `on_behalf_of`.\n *\n * @param on_behalf_of The address that has authorized the `inner_hash`\n * @param inner_hash The hash of the message to authorize\n */\npub fn compute_authwit_nullifier(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [on_behalf_of.to_field(), inner_hash],\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER,\n    )\n}\n\n/**\n * Computes the `message_hash` for the authentication witness\n *\n * @param consumer The address of the contract that is consuming the message\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param inner_hash The hash of the \"inner\" message that is being consumed\n */\npub fn compute_authwit_message_hash(\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    inner_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [consumer.to_field(), chain_id, version, inner_hash],\n        GENERATOR_INDEX__AUTHWIT_OUTER,\n    )\n}\n\n/**\n * Helper function to set the authorization status of a message hash\n *\n * Wraps a public call to the authentication registry to set the authorization status of a `message_hash`\n *\n * @param message_hash The hash of the message to authorize\n * @param authorize True if the message should be authorized, false if it should be revoked\n */\npub unconstrained fn set_authorized(\n    context: &mut PublicContext,\n    message_hash: Field,\n    authorize: bool,\n) {\n    let res = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"set_authorized(Field,bool)\") },\n        [message_hash, authorize as Field].as_slice(),\n        GasOpts::default(),\n    );\n    assert(res.len() == 0);\n}\n\n/**\n * Helper function to reject all authwits\n *\n * Wraps a public call to the authentication registry to set the `reject_all` flag\n *\n * @param reject True if all authwits should be rejected, false otherwise\n */\npub unconstrained fn set_reject_all(context: &mut PublicContext, reject: bool) {\n    let res = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"set_reject_all(bool)\") },\n        [context.this_address().to_field(), reject as Field].as_slice(),\n        GasOpts::default(),\n    );\n    assert(res.len() == 0);\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "67": {
      "path": "/c/Users/emili/nargo/github.com/AztecProtocol/aztec-packages/v0.82.0/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T, let N: u32> CapsuleArray<T>\nwhere\n    T: Serialize<N> + Deserialize<N>,\n{\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push(self, value: T) {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get(self, index: u32) -> T {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().unkonstrained().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n}\n"
    },
    "68": {
      "path": "/c/Users/emili/nargo/github.com/AztecProtocol/aztec-packages/v0.82.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, traits::Deserialize,\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\n\nuse crate::hash::hash_args;\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn call<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n        let returns: T = returns_hash.get_preimage();\n        returns\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateVoidCallInterface\n\npub struct PrivateVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static }\n    }\n\n    pub fn call(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                false,\n            )\n            .assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PrivateStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    pub fn view<let M: u32>(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        execution_cache::store(self.args);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PrivateStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticVoidCallInterface\n\npub struct PrivateStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n}\n\nimpl<let N: u32> PrivateStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: (), is_static: true }\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        execution_cache::store(self.args);\n        context\n            .call_private_function_with_args_hash(\n                self.target_contract,\n                self.selector,\n                self.args_hash,\n                true,\n            )\n            .assert_empty();\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PrivateStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let N: u32, T> PublicCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicVoidCallInterface\n\npub struct PublicVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.set_public_teardown_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            false,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let N: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32, T> PublicStaticCallInterface<N, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view<let M: u32>(self, context: &mut PublicContext) -> T\n    where\n        T: Deserialize<M>,\n    {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array::<M>())\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32, T> CallInterface<N> for PublicStaticCallInterface<N, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticVoidCallInterface\n\npub struct PublicStaticVoidCallInterface<let N: u32> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    return_type: (), // Unit type () indicates this interface is for functions that return nothing (void)\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let N: u32> PublicStaticVoidCallInterface<N> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<N>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: (),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub unconstrained fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        assert(returns.len() == 0);\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let args_hash = hash_args(self.args);\n        execution_cache::store(self.args);\n        context.call_public_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let N: u32> CallInterface<N> for PublicStaticVoidCallInterface<N> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n"
    },
    "75": {
      "path": "/c/Users/emili/nargo/github.com/AztecProtocol/aztec-packages/v0.82.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use dep::protocol_types::debug_log::debug_log_format;\n\nuse crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            enqueue_public_function_call_internal, notify_set_min_revertible_side_effect_counter,\n            set_public_teardown_function_call_internal,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS, PUBLIC_DISPATCH_SELECTOR,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, FromField, Hash, ToField},\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n\n        // WARNING(https://github.com/AztecProtocol/aztec-packages/issues/10558): if you delete this debug_log_format line, some tests fail.\n        debug_log_format(\n            \"Context.note_hashes, after pushing new note hash: {0}\",\n            self.note_hashes.storage().map(|nh: NoteHash| nh.value),\n        );\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        execution_cache::store(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request =\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index],\n                },\n            );\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_public_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.call_public_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        self.call_public_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_public_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle hashes the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = unsafe {\n            enqueue_public_function_call_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                counter,\n                is_static_call,\n            )\n        };\n\n        // Public calls are rerouted through the dispatch function.\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args);\n        self.set_public_teardown_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn set_public_teardown_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        // Safety: TODO(https://github.com/AztecProtocol/aztec-packages/issues/8985): Fix this.\n        // WARNING: This is insecure and should be temporary!\n        // The oracle hashes the arguments and returns a new args_hash.\n        // new_args = [selector, ...old_args], so as to make it suitable to call the public dispatch function.\n        // We don't validate or compute it in the circuit because a) it's harder to do with slices, and\n        // b) this is only temporary.\n        let args_hash = unsafe {\n            set_public_teardown_function_call_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                counter,\n                is_static_call,\n            )\n        };\n\n        let function_selector = comptime { FunctionSelector::from_field(PUBLIC_DISPATCH_SELECTOR) };\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            function_selector,\n            is_static_call,\n            args_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "76": {
      "path": "/c/Users/emili/nargo/github.com/AztecProtocol/aztec-packages/v0.82.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n\n        call(gas_for_call(gas_opts), contract_address, args);\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let args = args.push_front(function_selector.to_field());\n\n        call_static(gas_for_call(gas_opts), contract_address, args);\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    [user_gas.l2_gas.unwrap_or(MAX_FIELD_VALUE), user_gas.da_gas.unwrap_or(MAX_FIELD_VALUE)]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(gas: [Field; 2], address: AztecAddress, args: [Field]) {\n    call_opcode(gas, address, args)\n}\n\nunconstrained fn call_static(gas: [Field; 2], address: AztecAddress, args: [Field]) {\n    call_static_opcode(gas, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "77": {
      "path": "/c/Users/emili/nargo/github.com/AztecProtocol/aztec-packages/v0.82.0/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.hash, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.hash\n    }\n\n    /// This is only used during private execution, since in public it is the VM itself that keeps track of return\n    /// values.\n    pub fn get_preimage<T, let N: u32>(self) -> T\n    where\n        T: Deserialize<N>,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it.\n        let preimage: [Field; N] = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage));\n\n        Deserialize::deserialize(preimage)\n    }\n}\n"
    },
    "78": {
      "path": "/c/Users/emili/nargo/github.com/AztecProtocol/aztec-packages/v0.82.0/noir-projects/aztec-nr/aztec/src/context/unconstrained_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UnconstrainedContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UnconstrainedContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create an UnconstrainedContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "80": {
      "path": "/c/Users/emili/nargo/github.com/AztecProtocol/aztec-packages/v0.82.0/noir-projects/aztec-nr/aztec/src/discovery/mod.nr",
      "source": "// TODO(#12750): don't make this value assume we're using AES.\nuse crate::encrypted_logs::log_assembly_strategies::default_aes128::note::encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\nuse dep::protocol_types::{address::AztecAddress, debug_log::debug_log};\n\npub mod private_logs;\npub mod private_notes;\npub mod partial_notes;\npub mod nonce_discovery;\n\n/// We reserve two fields in the note private log that are not part of the note content: one for the storage slot, and\n/// one for the combined log and note type ID.\nglobal PRIVATE_LOG_EXPANDED_METADATA_LEN: u32 = 1;\n\n/// The maximum length of the log's content, i.e. after log type ID and metadata extraction.\npub global MAX_LOG_CONTENT_LEN: u32 =\n    PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS - PRIVATE_LOG_EXPANDED_METADATA_LEN;\n\nuse private_notes::MAX_NOTE_PACKED_LEN;\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, nonce, storage slot and note type\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\n/// address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowldge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    private_logs::fetch_and_process_private_tagged_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n}\n"
    },
    "81": {
      "path": "/c/Users/emili/nargo/github.com/AztecProtocol/aztec-packages/v0.82.0/noir-projects/aztec-nr/aztec/src/discovery/nonce_discovery.nr",
      "source": "use crate::{\n    discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    array::for_each_in_bounded_vec(\n        unique_note_hashes_in_tx,\n        |expected_unique_note_hash, i| {\n            // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n            // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n            let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n            // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n            // the note hash at the array index we're currently processing.\n            // TODO(#11157): handle failed note_hash_and_nullifier computation\n            let hashes = compute_note_hash_and_nullifier(\n                packed_note,\n                storage_slot,\n                note_type_id,\n                contract_address,\n                candidate_nonce,\n            )\n                .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n            let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n            let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n            if unique_note_hash == expected_unique_note_hash {\n                // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n                // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n                // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n                // PXE may fail to realize that a given note has been nullified already, and calls to the application\n                // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n                // application already has more direct means of making a call to it fail the transaction.\n                discovered_notes.push(\n                    DiscoveredNoteInfo {\n                        nonce: candidate_nonce,\n                        note_hash: hashes.note_hash,\n                        inner_nullifier: hashes.inner_nullifier,\n                    },\n                );\n\n                // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n                // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n                // notes containing random values in order to hide their contents.\n            }\n        },\n    );\n\n    debug_log_format(\n        \"Discovered a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n"
    },
    "82": {
      "path": "/c/Users/emili/nargo/github.com/AztecProtocol/aztec-packages/v0.82.0/noir-projects/aztec-nr/aztec/src/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    discovery::{\n        ComputeNoteHashAndNullifier,\n        MAX_LOG_CONTENT_LEN,\n        nonce_discovery::{attempt_note_nonce_discovery, DiscoveredNoteInfo},\n    },\n    oracle::message_discovery::{deliver_note, get_log_by_tag},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::PUBLIC_LOG_DATA_SIZE_IN_FIELDS,\n    debug_log::debug_log_format,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_LOG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private log (e.g.\n/// the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_LOG_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_LOG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\n// TODO(#11630): come up with some sort of slot allocation scheme.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = 77;\n\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\n/// the packed public content.\n// TODO(#10273): improve how contract log siloing is handled\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\n\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\n/// size and extra fields in the log (e.g. the tag).\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\n    PUBLIC_LOG_DATA_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_log(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    log_metadata: u64,\n    log_content: BoundedVec<Field, MAX_LOG_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_log(log_metadata, log_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\n/// notes being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    let mut i = 0;\n    while i < pending_partial_notes.len() {\n        let pending_partial_note: DeliveredPendingPartialNote = pending_partial_notes.get(i);\n\n        let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            i += 1 as u32;\n            // Note that we're not removing the pending partial note from the PXE DB, so we will continue searching\n            // for this tagged log when performing message discovery in the future until we either find it or the\n            // entry is somehow removed from the PXE DB.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public logs have an extra field at the beginning with the contract address, which we use to verify\n            // that we're getting the logs from the expected contract.\n            // TODO(#10273): improve how contract log siloing is handled\n            assert_eq(\n                log.log_content.get(0),\n                contract_address.to_field(),\n                \"Got a public log emitted by a different contract\",\n            );\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the log sans the extra fields) to get the\n            // complete packed content.\n            let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\n                array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                packed_public_note_content,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            array::for_each_in_bounded_vec(\n                discovered_notes,\n                |discovered_note: DiscoveredNoteInfo, _| {\n                    // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\n                    // temporary node connectivity issue - is simply throwing good enough here?\n                    assert(\n                        deliver_note(\n                            contract_address,\n                            pending_partial_note.storage_slot,\n                            discovered_note.nonce,\n                            complete_packed_note,\n                            discovered_note.note_hash,\n                            discovered_note.inner_nullifier,\n                            log.tx_hash,\n                            pending_partial_note.recipient,\n                        ),\n                        \"Failed to deliver note\",\n                    );\n                },\n            );\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\n            // being completed.\n            pending_partial_notes.remove(i);\n\n            // We don't increment `i` here, because CapsuleArray is contiguous and its `remove(...)` function\n            // shifts the elements to the left if the removed element is not the last element.\n        }\n    }\n}\n\nfn decode_partial_note_private_log(\n    log_metadata: u64,\n    log_content: BoundedVec<Field, MAX_LOG_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = log_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        log_content.len() > PARTIAL_NOTE_PRIVATE_LOG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note log: all partial note private logs must have at least {PARTIAL_NOTE_PRIVATE_LOG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_LOG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private log encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_LOG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_LOG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = log_content.get(0);\n    let note_completion_log_tag = log_content.get(1);\n\n    let packed_private_note_content = array::subbvec(log_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "83": {
      "path": "/c/Users/emili/nargo/github.com/AztecProtocol/aztec-packages/v0.82.0/noir-projects/aztec-nr/aztec/src/discovery/private_logs.nr",
      "source": "use crate::{oracle::message_discovery::sync_notes, utils::array};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PRIVATE_LOG_SIZE_IN_FIELDS},\n    debug_log::{debug_log, debug_log_format},\n};\n\nuse crate::discovery::{\n    ComputeNoteHashAndNullifier, MAX_LOG_CONTENT_LEN,\n    partial_notes::process_partial_note_private_log, PRIVATE_LOG_EXPANDED_METADATA_LEN,\n    private_notes::process_private_note_log,\n};\nuse crate::encrypted_logs::log_assembly_strategies::default_aes128::note::encryption::decrypt_log;\n// TODO(#12750): don't make this value assume we're using AES.\nuse crate::encrypted_logs::log_assembly_strategies::default_aes128::note::encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\n/// public logs that will complete them.\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\n    _contract_address: AztecAddress,\n    _compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // We will eventually fetch tagged logs, decrypt and process them here, but for now we simply call the `syncNotes`\n    // oracle. This has PXE perform tag synchronization, log download, decryption, and finally calls to the the\n    // `process_log` contract function with the decrypted payload, which will in turn call `do_process_log` with a\n    // decrypted log, letting us continue the work outside of PXE.\n    sync_notes();\n}\n\n/// Processes a log's ciphertext by decrypting it and then searching the plaintext for private notes or partial notes.\n///\n/// Private notes result in nonce discovery being performed prior to delivery, which requires knowledge of the\n/// transaction hash in which the notes would've been created (typically the same transaction in which the log was\n/// emitted), along with the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier`\n/// function.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\npub unconstrained fn do_process_log<Env>(\n    contract_address: AztecAddress,\n    log: BoundedVec<Field, PRIVATE_LOG_SIZE_IN_FIELDS>,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log_format(\"Processing log with tag {0}\", [log.get(0)]);\n\n    let log_plaintext = decrypt_log(log, recipient);\n\n    // The first thing to do after decrypting the log is to determine what type of private log we're processing. We\n    // currently just have two log types: 0 for private notes and 1 for partial notes. This will likely be expanded and\n    // improved upon in the future to also handle events, etc.\n\n    let (log_type_id, log_metadata, log_content) = decode_log_plaintext(log_plaintext);\n\n    if log_type_id == 0 {\n        debug_log(\"Processing private note log\");\n\n        process_private_note_log(\n            contract_address,\n            tx_hash,\n            unique_note_hashes_in_tx,\n            first_nullifier_in_tx,\n            recipient,\n            compute_note_hash_and_nullifier,\n            log_metadata,\n            log_content,\n        );\n    } else if log_type_id == 1 {\n        debug_log(\"Processing partial note private log\");\n\n        process_partial_note_private_log(contract_address, recipient, log_metadata, log_content);\n    } else {\n        // TODO(#11569): handle events\n        debug_log_format(\n            \"Unknown log type id {0} (probably belonging to an event log)\",\n            [log_type_id as Field],\n        );\n    }\n}\n\n/// Decodes a log's plaintext following aztec-nr's standard log encoding.\n///\n/// The standard private log layout is composed of:\n///  - an initial field called the 'expanded metadata'\n///  - an arbitrary number of fields following that called the 'log content'\n///\n/// ```\n/// log_plainext: [ log_expanded_metadata, ...log_content ]\n/// ```\n///\n/// The expanded metadata itself is (currently) interpreted as a u64, of which:\n///  - the upper 57 bits are the log type id\n///  - the remaining 7 bits are called the 'log metadata'\n///\n/// ```\n/// log_expanded_metadata: [  log_type_id   |  log_metadata ]\n///                        <--- 57 bits --->|<--- 7 bits --->\n/// ```\n///\n/// The meaning of the log metadata and log content depend on the value of the log type id. Note that there is\n/// nothing special about the log metadata, it _can_ be considered part of the content. It just has a different name\n/// to make it distinct from the log content given that it is not a full field.\nunconstrained fn decode_log_plaintext(\n    log_plaintext: BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>,\n) -> (u64, u64, BoundedVec<Field, MAX_LOG_CONTENT_LEN>) {\n    assert(\n        log_plaintext.len() >= PRIVATE_LOG_EXPANDED_METADATA_LEN,\n        f\"Invalid log plaintext: all logs must be decrypted into at least {PRIVATE_LOG_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If PRIVATE_LOG_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the log encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_LOG_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for PRIVATE_LOG_EXPANDED_METADATA_LEN\",\n    );\n\n    // See the documentation of this function for a description of the log layout\n    let expanded_log_metadata = log_plaintext.get(0);\n\n    let log_type_id = ((expanded_log_metadata as u64) / 128);\n    let log_metadata = ((expanded_log_metadata as u64) % 128);\n\n    let log_content = array::subbvec(log_plaintext, PRIVATE_LOG_EXPANDED_METADATA_LEN);\n\n    (log_type_id, log_metadata, log_content)\n}\n"
    },
    "84": {
      "path": "/c/Users/emili/nargo/github.com/AztecProtocol/aztec-packages/v0.82.0/noir-projects/aztec-nr/aztec/src/discovery/private_notes.nr",
      "source": "use crate::{\n    discovery::{\n        ComputeNoteHashAndNullifier,\n        MAX_LOG_CONTENT_LEN,\n        nonce_discovery::{attempt_note_nonce_discovery, DiscoveredNoteInfo},\n    },\n    oracle,\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note log content that are not the note's packed representation.\nglobal PRIVATE_NOTE_LOG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the log (e.g. log type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_LOG_CONTENT_LEN - PRIVATE_NOTE_LOG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_log<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    log_metadata: u64,\n    log_content: BoundedVec<Field, MAX_LOG_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_log(log_metadata, log_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private log\",\n        [discovered_notes.len() as Field],\n    );\n\n    array::for_each_in_bounded_vec(\n        discovered_notes,\n        |discovered_note: DiscoveredNoteInfo, _| {\n            // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\n            // issue, and we should perhaps not have marked the tag index as taken.\n            assert(\n                oracle::message_discovery::deliver_note(\n                    contract_address,\n                    storage_slot,\n                    discovered_note.nonce,\n                    packed_note,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    tx_hash,\n                    recipient,\n                ),\n                \"Failed to deliver note\",\n            );\n        },\n    );\n}\n\nfn decode_private_note_log(\n    log_metadata: u64,\n    log_content: BoundedVec<Field, MAX_LOG_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = log_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        log_content.len() > PRIVATE_NOTE_LOG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note log: all private note logs must have at least {PRIVATE_NOTE_LOG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_LOG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the private note log encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_LOG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_LOG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = log_content.get(0);\n    let packed_note = array::subbvec(log_content, PRIVATE_NOTE_LOG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "85": {
      "path": "/c/Users/emili/nargo/github.com/AztecProtocol/aztec-packages/v0.82.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypt/aes128.nr",
      "source": "use dep::protocol_types::{\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::utils::point::point_to_bytes;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n"
    },
    "91": {
      "path": "/c/Users/emili/nargo/github.com/AztecProtocol/aztec-packages/v0.82.0/noir-projects/aztec-nr/aztec/src/encrypted_logs/log_assembly_strategies/default_aes128/note/encryption.nr",
      "source": "use crate::{\n    encrypted_logs::{\n        encrypt::aes128::derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256,\n        log_assembly_strategies::default_aes128::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    oracle::{\n        aes128_decrypt::aes128_decrypt_oracle,\n        notes::{get_app_tag_as_sender, increment_app_tagging_secret_index_as_sender},\n        shared_secret::get_shared_secret,\n    },\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign},\n        random::get_random_bytes,\n    },\n};\nuse protocol_types::{address::AztecAddress, constants::PRIVATE_LOG_SIZE_IN_FIELDS, traits::ToField};\nuse std::aes128::aes128_encrypt;\n\n// contract_address (32) + ciphertext_length (2) + 16 bytes pkcs#7 AES padding.\npub(crate) global HEADER_CIPHERTEXT_SIZE_IN_BYTES: u32 = 48;\n\nglobal TAG_AND_EPH_PK_X_SIZE_IN_FIELDS: u32 = 2;\nglobal EPH_PK_SIGN_BYTE_SIZE_IN_BYTES: u32 = 1;\npub global PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES: u32 = (\n    PRIVATE_LOG_SIZE_IN_FIELDS - TAG_AND_EPH_PK_X_SIZE_IN_FIELDS\n)\n    * 31\n    - HEADER_CIPHERTEXT_SIZE_IN_BYTES\n    - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES;\n// Each field of the original note log was serialized to 32 bytes. Below we convert the bytes back to fields.\npub global PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_BYTES / 32;\n\n/// Computes an encrypted log using AES-128 encryption in CBC mode.\n///\n/// The resulting log has the following format:\n/// ```text\n/// [\n///   tag: Field,                    // Tag for message discovery, derived from sender/recipient\n///   epk_x: Field,                  // X coordinate of ephemeral public key\n///   log_bytes: [Field],            // Encrypted data converted from bytes to fields, containing:\n///     [\n///       epk_sign: u8,              // Sign bit of ephemeral public key Y coordinate\n///       header_ciphertext: [u8],   // AES encrypted header containing:\n///         [\n///           contract_address: [u8; 32],  // Contract address that emitted the note\n///           ciphertext_length: [u8; 2],  // Length of main ciphertext in bytes\n///           padding: [u8; 14]            // PKCS#7 padding to AES block size\n///         ],\n///       ciphertext: [u8],          // AES encrypted note data containing:\n///         [\n///           plaintext_bytes: [u8],       // The plaintext\n///           padding: [u8]                // PKCS#7 padding to AES block size\n///         ],\n///       padding: [u8]              // Random padding to make log_bytes multiple of 31\n///     ],\n///   padding: [Field]               // Random padding to PRIVATE_LOG_SIZE_IN_FIELDS\n/// ]\n/// ```\n///\n/// The encryption process:\n/// 1. Generate ephemeral key-pair and ECDH shared secret with recipient\n/// 2. Derive AES key and IV from shared secret using SHA-256\n/// 3. Encrypt header and note data separately using AES-128-CBC\n/// 4. Format into final log structure with padding\npub fn encrypt_log<let PT: u32>(\n    contract_address: AztecAddress,\n    plaintext: [Field; PT],\n    recipient: AztecAddress,\n    sender: AztecAddress,\n) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS] {\n    // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n    // (This process is then reversed when processing the log in `do_process_log`)\n    let plaintext_bytes = fields_to_bytes(plaintext);\n\n    // *****************************************************************************\n    // Compute the shared secret\n    // *****************************************************************************\n\n    let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n    let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n    // (not to be confused with the tagging shared secret)\n    let ciphertext_shared_secret = derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n    // TODO: also use this shared secret for deriving note randomness.\n\n    // *****************************************************************************\n    // Convert the plaintext into whatever format the encryption function expects\n    // *****************************************************************************\n\n    // Already done for this strategy: AES expects bytes.\n\n    // *****************************************************************************\n    // Encrypt the plaintext\n    // *****************************************************************************\n\n    let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n        ciphertext_shared_secret,\n    );\n\n    let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n    // |full_pt| = |pt_length| + |pt|\n    // |pt_aes_padding| = 16 - (|full_pt| % 16)\n    // or... since a % b is the same as a - b * (a // b) (integer division), so:\n    // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n    // |ct| = |full_pt| + |pt_aes_padding|\n    //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n    //      = 16 + 16 * (|full_pt| // 16)\n    //      = 16 * (1 + |full_pt| // 16)\n    assert(ciphertext_bytes.len() == 16 * (1 + (PT * 32) / 16));\n\n    // *****************************************************************************\n    // Compute the header ciphertext\n    // *****************************************************************************\n\n    let contract_address_bytes = contract_address.to_field().to_be_bytes::<32>();\n\n    let mut header_plaintext: [u8; 32 + 2] = [0; 32 + 2];\n    for i in 0..32 {\n        header_plaintext[i] = contract_address_bytes[i];\n    }\n    let offset = 32;\n    let ciphertext_bytes_length = ciphertext_bytes.len();\n    header_plaintext[offset] = (ciphertext_bytes_length >> 8) as u8;\n    header_plaintext[offset + 1] = ciphertext_bytes_length as u8;\n\n    // TODO: this is insecure and wasteful:\n    // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n    // and again for the proper ciphertext) (at least, I never got the\n    // \"go ahead\" that this would be safe, unfortunately).\n    // \"Wasteful\", because the exact same computation is happening further down.\n    // I'm leaving that 2nd computation where it is, because this 1st computation\n    // will be imminently deleted, when the header logic is deleted.\n    let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n        ciphertext_shared_secret,\n    );\n\n    // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n    // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n    // bytes larger than the input in this case.\n    let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n    // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n    assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n    // *****************************************************************************\n    // Prepend / append more bytes of data to the ciphertext, before converting back\n    // to fields.\n    // *****************************************************************************\n\n    let mut log_bytes_padding_to_mult_31 = get_arr_of_size__log_bytes_padding__from_PT::<PT * 32>();\n    // Safety: this randomness won't be constrained to be random. It's in the\n    // interest of the executor of this fn to encrypt with random bytes.\n    log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n    let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PT * 32>();\n\n    assert(\n        log_bytes.len() % 31 == 0,\n        \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n    );\n\n    log_bytes[0] = eph_pk_sign_byte;\n    let mut offset = 1;\n    for i in 0..header_ciphertext_bytes.len() {\n        log_bytes[offset + i] = header_ciphertext_bytes[i];\n    }\n    offset += header_ciphertext_bytes.len();\n\n    for i in 0..ciphertext_bytes.len() {\n        log_bytes[offset + i] = ciphertext_bytes[i];\n    }\n    offset += ciphertext_bytes.len();\n\n    for i in 0..log_bytes_padding_to_mult_31.len() {\n        log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n    }\n\n    assert(\n        offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n        \"Something has gone wrong\",\n    );\n\n    // *****************************************************************************\n    // Convert bytes back to fields\n    // *****************************************************************************\n\n    // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n    // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n    // should cover a full field.\n    let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n    // *****************************************************************************\n    // Prepend / append fields, to create the final log\n    // *****************************************************************************\n\n    // In this strategy, we prepend [tag, eph_pk.x]\n\n    // Safety: We assume that the sender wants for the recipient to find the tagged note,\n    // and therefore that they will cooperate and use the correct tag. Usage of a bad\n    // tag will result in the recipient not being able to find the note automatically.\n    let tag = unsafe { get_app_tag_as_sender(sender, recipient) };\n    increment_app_tagging_secret_index_as_sender(sender, recipient);\n\n    let mut final_log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS] = [0; PRIVATE_LOG_SIZE_IN_FIELDS];\n\n    final_log[0] = tag;\n    final_log[1] = eph_pk.x;\n\n    let mut offset = 2;\n    for i in 0..log_bytes_as_fields.len() {\n        final_log[offset + i] = log_bytes_as_fields[i];\n    }\n    offset += log_bytes_as_fields.len();\n\n    for i in offset..PRIVATE_LOG_SIZE_IN_FIELDS {\n        // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n        // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n        // TODO(#12749): Long term, this is not a good solution.\n\n        // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n        // contents publicly. It is therefore fine to trust the sender to provide random padding.\n        let field_bytes = unsafe { get_random_bytes::<31>() };\n        final_log[i] = Field::from_be_bytes::<31>(field_bytes);\n    }\n\n    final_log\n}\n\npub unconstrained fn decrypt_log(\n    log: BoundedVec<Field, PRIVATE_LOG_SIZE_IN_FIELDS>,\n    recipient: AztecAddress,\n) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n    // let tag = log.get(0);\n    let eph_pk_x = log.get(1);\n\n    let log_ciphertext_fields = array::subbvec::<Field, PRIVATE_LOG_SIZE_IN_FIELDS, PRIVATE_LOG_SIZE_IN_FIELDS - TAG_AND_EPH_PK_X_SIZE_IN_FIELDS>(\n        log,\n        TAG_AND_EPH_PK_X_SIZE_IN_FIELDS,\n    );\n\n    // Convert the ciphertext represented as fields to a byte representation (its original format)\n    let log_ciphertext = bytes_from_fields(log_ciphertext_fields);\n\n    // First byte of the ciphertext represents the ephemeral public key sign\n    let eph_pk_sign_bool = log_ciphertext.get(0) as bool;\n    // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n    let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n    // Derive shared secret and symmetric key\n    let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n    let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n        ciphertext_shared_secret,\n    );\n\n    // Extract the header ciphertext\n    let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n    let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n        array::subarray(log_ciphertext.storage(), header_start);\n    // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n    // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n    // is fixed. But we do it anyway to not have to have duplicate oracles.\n    let header_ciphertext_bvec =\n        BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n    // Decrypt header\n    let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n    // Extract ciphertext length from header (2 bytes, big-endian)\n    let ciphertext_length =\n        ((header_plaintext.get(32) as u32) << 8) | (header_plaintext.get(33) as u32);\n\n    // Extract and decrypt main ciphertext\n    let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n    let ciphertext_with_padding: [u8; (PRIVATE_LOG_SIZE_IN_FIELDS - TAG_AND_EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n        array::subarray(log_ciphertext.storage(), ciphertext_start);\n    let ciphertext: BoundedVec<u8, (PRIVATE_LOG_SIZE_IN_FIELDS - TAG_AND_EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n        BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n    // Decrypt main ciphertext and return it\n    let log_plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n    // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n    fields_from_bytes(log_plaintext_bytes)\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::{decrypt_log, encrypt_log, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS};\n    use protocol_types::{address::AztecAddress, traits::FromField};\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let contract_address = AztecAddress::from_field(\n            0x10f48cd9eff7ae5b209c557c70de2e657ee79166868676b787e9417e19260e04,\n        );\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        let sender = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns([69420, 1337]);\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log =\n            BoundedVec::from_array(encrypt_log(contract_address, plaintext, recipient, sender));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret);\n\n        // Decrypt the log\n        let decrypted = decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n    }\n}\n"
    },
    "98": {
      "path": "/c/Users/emili/nargo/github.com/AztecProtocol/aztec-packages/v0.82.0/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    }
  }
}
